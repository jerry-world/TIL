# ==과 Equals 그리고 Hashcode

# ==과 Equals

==비교는 자바의 원시타입에서는 값을 비교하는 역할을 수행한다.

하지만, 참조타입에서는 조금 이야기가 다르다. 참조타입에서는 ==비교는 해당 객체의 값이 아닌 주소 값을 의미한다. 그렇기 떄문에 객체간의 ==비교를 수행하는 것은 객체 자체가 동일한 객체인지를 비교하는 행위이다.

Equals는 오브젝트 클래스 메서드로, 모든 자바 객체에서 Equals 메서드를 재정의할 수 있다.

가령 우리가 사용하는 String은 Equals 메서드를 재정의하였는데,

```java
String a = "abc";
String b = a;
String c = new String("abc");
```

위에서 언급한 == 비교를 통해 a, b, c가 같은지를 서로 비교해보면 a와 b는 같지만 c는 다른 대상이다. 왜냐하면 주소값이 다르기 때문에,

하지만 Equals를 사용하면 a, b, c 모두 동등 객체라고 판단한다. 그이유는 String에서는 객체의 주소가 다르더라도 String의 값이 동일하면 동등 객체로 판단하도록 Equals 메서드를 재정의 했기 때문이다.

# equals()와 hashcode()

보통 equals를 재정의하면 hashcode도 재정의 해야한다고 말한다. 그 이유에 대해 살펴보자.

위에서 말한바와같이 String은 서로 값이 같으면 동등객체라고 판단한다. 하지만, hashcode의 고유성질로 이 a와 주소값이 다른 c는 다른 hashcode를 반환한다.

이렇게되면 서로 동등하지 않다고 판단하는 것이 맞다.

Equals만 재정의된 자동차 클래스가 있다고 가정해보자. 여기서 자동차 클래스는 자동차의 이름이 같으면 동일한 객체라고 판단하기로 equals를 재정의 하였다.

이때 hashcode를 재정의 하지 않았다면, equals메서드 상으로는 서로 같은 객체라고 판단할지라도 hashcode는 서로 다른 객체임을 가르키고 있을 것이다.

만약 이 자동차 객체를 HashSet에 담는다고하면 HashSet에서는 객체의 해시코드와 equals를 통해, 논리적으로 이 대상이 같은지를 판별하는데, hashcode가 다르기 때문에 이 이름은 같지만 hashcode가 다른 두 객체가 함께 저장될 것이다.