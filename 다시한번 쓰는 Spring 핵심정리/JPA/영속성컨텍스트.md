# 영속성 컨텍스트(Persistence Context)

`Persistence Context`는 영어 단어 그대로, 무언가를 영속적으로 관리하는 환경으로 말할 수 있다.

여기서 말하는 무언가는 JPA에 의해 관리되는 `Entity` 라는 대상을 의미한다.

이 페이지에서는, JPA(Java Persistence API)에서 취급하는 

```java
private final EntityManager entityManager;
//...
public void addItem(String itemName) {
    Item item = new Item(itemName);
    entityManager.persist(item);
}
```
위와 같이 EntityManager를 통해 새로운 Item을 영속(Persist)하면,
JPA 가 추적중인 상태(영속 상태)가 된다.

## 왜 영속성 컨텍스트라는 단어를 사용했을까?
일반적으로 Java 객체는 new 키워드를 사용하여 특정 클래스에 대한 인스턴스를 생성한다.
 이때 힙메모리 영역에 인스턴스가 존재하다가, 더이상 Root Set에서의 연결고리가 끊어지면, GC에 의해 소멸된다.

하지만, JPA의 주요 목적은 `DB와 Java Object를 긴밀하게 연결`하는 것이다.

JPA에서 관리하는 대상을 'Entity'라고 정의하는데, 이 Entity는 단순히 신규 인스턴스를 만들었을 때,

`메모리에 존재하는 객체` 따위로 취급하는 것이 아닌 `JPA가 잘 관리하고 있다가 DB에 연결시켜줘야하는 객체` 라고 취급합니다. 떄문에 영속성 이라는 단어를 사용한다.

그러면 잘 캐싱했다가 DB에 연결시켜주면되는건데 왜 컨텍스트라고 불리우느냐. 사실 JPA는 단순히 Entity의 생명주기만을 관리하는 것은 아니다.

엔티티의 상태 변화, SQL을 실행할 시점, 트랜잭션 동기화 등을 총괄하여 수행하는 하나의 맥락, 환경이다.

Context라는 단어는 Spring에서 Application Context처럼 Bean들을 관리하는 스프링 환경 이라는 의미로 해석될 수 있듯이,

JPA에서의 Persistence Context는 영속적으로 엔티티를 관리하는 환경이라고 말할 수 있다.

다시말해 Persistence Context란, 엔티티 객체를 식별자(PK) 기준으로 관리하며,

그 생명주기와 상태 변화를 추적하여 DB와의 동기화를 담당하는 환경이다.

DB에게 연결시켜준다는 말은 트랜잭션 커밋 시점에 flush하여 DB에 반영한다는 말이다.

## 영속성 컨텍스트의 엔티티 상태 관리
앞서 영속성 컨테스트가 엔티티의 생명 주기를 관리한다고 언급하였다.

한 트랜잭션에서 발생되는 신규 엔티티나, 엔티티의 상태 변경 등의 수행은 영속성 컨텍스트에 의해

엔티티 생명주기에 따라 관리되고 DB에 반영된다.

엔티티 생명주기는 JPA가 엔티티 객체를 `transient -> persist -> detach -> remove` 상태로 관리하는 과정 전체를 말한다.

인테테는 JPA의 메서드 호출이나 트랜잭션 종료에 따라 상태가 바뀌게 된다.

```scss
new Somthing() // transient -> persist(somthing) -> managed -> remove() -> deleted
                                    ㄴ> detach() -> detached
                                    ㄴ> clear() -> all detached
                                    ㄴ> close() -> close the persistence context 
```

그럼 각 상태 구간별 예시를 살펴보자.

### transient, persist
transient 상태라는 것은 JPA에 의해 관리되지 않는 상태를 말한다. 영속성 컨텍스트가 Entity를 관리하면 Persist 상태가 된다.

이 Persist 상태의 엔티티는 속해있는 트랜잭션이 종료되면, flush 되어 데이터베이스에 반영된다. 말인 즉슨, 새롭게 생셩된 student가 DB에 적재된다.
```java
Student student = new Student(); //인스턴스만 만들어진 상태 (비영속)
entityManager.persist(student); // EntityManager에 의해 영속된 상태 (영속)
```
persist 메서드를 통해 생성된 Entity가될 인스턴스를 전달하면 영속성 컨텍스트의 엔티티를 관리하는 공간(관습적으로 `1차캐시`라 부름)에에 저장된다.

식별자(PK) 기반으로 관리되며 동일성(==)을 보장한다.

또한, 변경감지(Dirty Checking)를 시작한다.

### detach
persist된 엔티티를 detach하면 엔티티 매니저로부터 더이상 관리받지않는 상태가 된다. 단순히 transient한 상태와 동일한 상태가된다.

사실, Spring JPA 를 사용하는 애플리케이션에서는 서비스 비즈니스로직 수행 이후 트랜잭션이 종료되기 이전 flush를 수행하고, clear를 수행하여, 영속성 컨텍스트를 비우는 행위를 수행한다.

그런데 의도하고 detach하는 그런 특수항 경우가 있을까 싶을 수 있다.

하지만, 영속성 컨텍스트가 관리하는 Entity 도 무한정 늘릴 수는 없다. 이 Entity를 한 트랜잭션에서 100개 1000개 10000개 관리하다보면, 분명 메모리 사용량 증가 / OOM 리스크의 문제가 발생할 수 있고,

때문에 대량의 Entity를 한트랜잭션에서 관리해줘야하는 상황이 있다면 의도적으로 처리가 완료된 Entity 주체에 대해서는 detach를 통해 더이상 관리되지 않도록 해주어야한다.

또는 트랜잭션 과정에서 의도치 않은 Dirty 액션이 발생할 수 있다. Entity를 조회하여 획득된 상태에서, Entity의 필드를 재정의한다던지의 문제를 예로 들 수 있다.

이러한 상황을 강제적으로 차단하기 위해 의도적으로 detach를 수행할 수도 있다.

> 나는 사실 이 detach한 상태를 준영속 상태라고 관습적으로 부르는데, 준영속 이라는 단어에서 오는 이질감이 좀 큰 편이다.
> 
> 영속성 컨텍스트로부터 분리된 상태 그대로로 봐야 이해가 되는 것 같다. 설령 한번 영속성 컨텍스트에 정의가 되었고 PK가 할당된 엔티티였다할지라도,
> 
> 영속성 컨텍스트로부터 분리된 상태라면 그냥 어감이 좀 늘어져도 단어 그대로 '분리된 상태'라고 보는게 맞다고 생각한다..


```java
entityManager.detach(student); // 특정 엔티티를 분리
entityManager.clear(); //컨텍스트에 할당된 엔티티 모두를 분리
entityManager.close(); //컨텍스트 종료
```

### remove
영속성 컨텍스트 내의 Entity를 제거한다. 제거라함은 단순 영속성 컨텍스트로부터 제거하는 것이 아닌, 실제 flush가 발생했을 때 DB 내의 데이터도 제거되는 것을 말한다.

### clear
영속성 컨텍스트 내의 Entity를 모두 해제(비우기)한다. 더이상 현 트랜잭션 내에서 관리하지 않는 상태가 된다.

가령, 트랜잭션이 flush되고 종료되기 이전 Persistence Context로부터 모든 엔티티가 자동으로 해제되고 종료된다.

### close
영속성 컨텍스트를 종료한다.
