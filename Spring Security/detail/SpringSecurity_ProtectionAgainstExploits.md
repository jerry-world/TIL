# Protection Against Exploits

## 😀 Cross Site Request Forgery (CSRF)

Spring은 사이트 간 요청 위조(이하, CSRF) 공격에 대한 방어를 종합적으로 지원합니다.

### What is a CSRF Attack?

CSRF 공격을 이해하려면 예시를 보는 것이 가장 좋습니다.

현재 로그인 된 계정에서 다른 은행 계좌로 돈을 송금하는 웹사이트를 만든다고 가정해보겠습니다.

다음과 같이 송금 폼을 제공합니다:

**Transfer form**

```html

<form method="post" action="/transfer">
  <input type="text" name="amount"/>
  <input type="text" name="routingNumber"/>
  <input type="text" name="account"/>
  <input type="submit" value="Transfer"/>
</form>
```

이 폼을 전송하면 HTTP 요청은 아래와 같을 것입니다:

**Transfer HTTP Request**

```
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876
```

이제 은행 웹사이트에서 인증 후, 로그아웃하지 않고 악의적인 웹사이트에 방문했다고 가정해보겠습니다.

악의적인 웹사이트의 HTML 페이지 폼은 아래와 같습니다:

**Evil transfer form**

```html

<form method="post" action="https://bank.example.com/transfer">
  <input type="hidden" name="amount" value="100.00"/>
  <input type="hidden" name="routingNumber" value="evilsRoutingNumber"/>
  <input type="hidden" name="account" value="evilsAccountNumber"/>
  <input type="submit" value="Win Money!"/>
</form>
```

돈을 준다고 해서, 당신은 제출 버튼을 눌렀습니다. 이 과정에서, 당신은 100달러를 악의적인 사용자에게 송금하였습니다. 이 것이 가능한 이유는 악의적인 사용자가 당신의 쿠키를
조회할 수는 없지만, 앞서 로그아웃하지 않은 은행 웹사이트에서의 쿠키도 악의적인 웹사이트에서 제출버튼과 함께 포함되었기 떄문입니다.

아직 끝나지 않았습니다. 이전체의 프로세스를 JavaScript를 사용하여 전부 자동화했을 수도 있습니다. 이말인즉슨, 당신이 제출버튼을 클릭하지 않았다는 것을 의미합니다.
게다가, 당신이 정직한 웹사이트 즉, 원래의 은행 웹사이트를 방문했다고
할지라도, [XSS 공격](https://owasp.org/www-community/attacks/xss/) 의 표적이 되면 똑같이 쉽게 재현할 수 있습니다.

그럼 어떻게 해야 이러한 공격으로부터 사용자를 보호할 수 있을까요?

### Protecting Against CSRF attacks

CSRF 공격이 가능한 이유는 공격받는 웹사이트의 HTTP 요청과 공격하는 웹사이트의 요청이 정확하게 동일하기 때문입니다. 이말인즉슨, 악의적인 웹사이트의 요청은 거절하고 은행
웹사이트의 요청 만을 수락하게 할 수 있는 방법이 명확하지 않다는 것을 의미합니다. 이러한 악의적인 CSRF 공격을 방어하려면, 악의적인 사이트에서 제공할 수 없는 무언가를 요청에
포함해서, 악의적인 요청과 일반적인 요청 이 두가지를 구분할 수 있어야합니다.

Spring은 CSRF 공격을 방어할 수 있는 2가지 매커니즘을 제공합니다:

- The [Synchronizer Token Pattern](https://www.notion.so/Protection-Against-Exploits-7f346a46014043e3a46630128d869aef)
- Specifying the [SameSite Attribute](https://docs.spring.io/spring-security/reference/features/exploits/csrf.html#csrf-protection-ssa) on your session cooke

<aside>
💡 위의 두가지 매커니즘 모두 Safe Method는 반드시 멱등성을 보장해야 합니다.

</aside>

### Safe Methods Must be Idempotent

CSRF 공격을 방어하는 위의 두가지 매커니즘이 잘 동작하려면 “safe”HTTP 메서드는 모두 멱등성을 보장해야합니다. 즉, HTTP 메서드 `GET`, `HEAD`
, `OPTIONS`, `TRACE` 요청은 애플리케이션 상태를 변화시키면 안됩니다.

### Synchronizer Token Pattern

CSRF 공격을 방어하는 방법은 Synchronizer Token Pattern이 지배적이며, 가장 포괄적입니다. 이 솔루션은 HTTP 요청에 세션 쿠키와는 별개로 CSRF
Token이라 불라는 Secure random(안전한 난수)을 생성하여, 이를 우리의 각 HTTP 요청에 저장합니다.

여기서 중요한 키 포인트는 HTTP 요청에 브라우저가 자동으로 이 값을 넣어주는 것이 아닌 CSRF 토큰이 있어야 한다는 것입니다. 예를 들어, HTTP 파라미터나 헤더에서
CSRF 토큰을 받으면 CSRF 공격을 방어할 수 있습니다. 쿠키는 브라우저가 HTTP 요청에 자동으로 포함시키기 때문에, CSRF 토큰을 쿠키에서 받으면 의미가 없습니다.

아래의 예제를 통해 Synchronizer Token Pattern을 사용하면 어떻게 바뀌는지 살펴봅시다. CSRF 토큰은 `_csrf` 이라는 이름으로 HTTP 파라미터로
받는다고 가정합시다.

애플리케이션의 송금 폼은 아래와 같습니다:

**Synchronizer Token Form**

```html

<form method="post" action="/transfer">
  <input type="hidden" name="_csrf" value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
  <input type="text" name="amount"/>
  <input type="text" name="routingNumber"/>
  <input type="hidden" name="account"/>
  <input type="submit" value="Transfer"/>
</form>
```

이제 폼은 hidden input 타입의 _csrf 필드에 CSRF Token 값을 가지고 있습니다. 외부 사이트에서는 동일 출처 정책에 따라 응답을 읽을 수 없기 때문에,
CSRF를 읽어갈 수 없습니다.

이에 따른 돈을 송금하는 HTTP 요청은 아래와 같습니다:

**Synchronizer Token request**

```
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876&**_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721**
```

CSRF TOKEN을 통해, HTTP요청에 CSRF 토큰의 값으로 안전한 난수가 들어있습니다. 악의적인 웹사이트에서는 CSRF 토큰 값을 정확하게 작성할 수 없으며, 서버에서
가지고 있는 CSRF 토큰과 실제 요청에 있는 CSRF 토큰이 일치해야 하기 때문에, CSRF 공격으로부터 안전해졌습니다.

### SameSite Attribute

최근에 생겨난 다른 CSRF 공격에 대한 방어 방법으로 `SameSite` 속성을 지정하는 방법이 있습니다. 서버는 외부 사이트가 보내는 요청엔 쿠키를 사용하지
않겠다고 `SameSite` 속성을 지정함으로써 이를 명시할 수 있습니다.

<aside>
💡 Spring Security는 세션 쿠키의 생성을 직접 제어하지 않기 때문에, `SamiteSite` 속성을 지원하지 않습니다.  서블릿 기반 애플리케이션에서 `Spring Session`은 `SameSite` 속성을 제공합니다. WebFlux 기반 애플리케이션에서는 Spring Framework의 [CookieWebSessionIdResolver](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/session/CookieWebSessionIdResolver.html)가 전용 `SameSite` 속성을 지원합니다.

</aside>

HTTP 응답 헤더에서 `SameSite` 속성을 사용하는 경우의 예시는 아래와 같습니다.

**SameSite HTTP response**

```
Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax
```

**SameSite** 속성으로 유효한 값은 아래와 같습니다:

- Strict - Strict로 지정할 경우, 동일 사이트가 보내는 모든 요청에 쿠키를 포함시킵니다. 그외의 HTTP 요청에는 쿠키를 추가하지 않습니다.
- Lax - Lax로 지정할 경우, 동일 사이트가 보내는 모든 요청에 쿠키를 포함시킵니다. 또는 사이트가 다르더라도, top-level navigation에서
  보낸요청이면서 [멱등성을 보장하는 메서드](https://www.notion.so/Protection-Against-Exploits-7f346a46014043e3a46630128d869aef) 일
  경우, 쿠키를 포함시킵니다. 그 외의 HTTP 요청에는 쿠키를 추가하지 않습니다.

우리의 예제에서 `SameSite` 속성을 사용하여 CSRF 공격으로부터 보호할 수 있는지 알아보겠습니다.

은행 애플리케이션은 세션 쿠키에 `SameSite` 속성을 명시하여 은행 애플리케이션을 CSRF 공격으로부터 방어할 수 있습니다.

`SameSite` 속성을 우리의 세션 쿠키에 설정하면, 브라우저는 은행 웹사이트로부터 오는 모든 요청에 `JSESSIONID`를 계속적으로 보냅니다. 그러나, 브라우저가 악의적인
웹사이트로부터 오는 요청에는 더 이상 `JSESSIONID`를 보내지 않습니다. 악의적인 웹사이트에서 보내는 송금 요청에는 더이상 세션이 존재하지 않기때문에(JSESSIONID가
없어서), CSRF 공격으로부터 애플리케이션을 보호할 수 있습니다.

여기에는 SameSite 속성을 사용하여 CSRF 공격을 방어할 때 꼭 알아둬야할 주의 사항이 있습니다.

`SameSite` 속성을 `Strict`로 지정하는 것이 보다 안전하지만, 사용자를 혼란스럽게 할 수 있습니다. 사용자가 https://social.example.com에서
호스팅하는 SNS에 로그인한 상태라고 가정해보겠습니다. 사용자는 https://email.example.org에서 이 SNS 사이트로 가는 링크가 적힌 이메일 하나를
전달받았습니다. 사용자는 이 링크를 클릭하면 당연히 SNS 사이트로 정상적으로 이동할 것이라고 생각하지만, `SameSite` 속성이 `Strict` 이기때문에 쿠키를 전송하지
않아 사용자를 인증할 수 없습니다.

<aside>
💡 [gh-7537](https://github.com/spring-projects/spring-security/issues/7537)을 구현하면 보안을 강화하면서도 CSRF 공격 방어를 위한 `SameSite` 사용성을 개선할 수 있습니다.

</aside>

또다른 주의해야할 점은, `SameSite` 속성으로 사용자를 보호하기 위해선, 브라우저는 반드시 `SameSite` 속성을 지원해야합니다. 대부분의 모던
브라우저들은 `SameSite` 속성을 지원합니다. 오래된 브라우저들은 이를 지원하지 않을 수도 있습니다.

### When to use CSRF protection

그러면 CSRF 방어는 어떨 때 사용해야 할까요? 우리는 일반 사용자가 브라우저에서 처리할 수 있는 모든 요청에 CSRF 방어를 적용하는 것을 권고합니다. 만약 만들고 있는
서비스를 브라우저가 아닌 클라이언트에서만 사용한다면 CSRF 방어를 비활성화하셔도 됩니다.

### CSRF protection and JSON

흔히 하는 질문으로 “javascript에서 만든 JSON 요청도 방어해야하나요?”라고 묻곤합니다. 짧게 대답하자면, 떄에 따라 다릅니다. 그러나, JSON 요청또한 CSRF
취약점에 매우 주의해야합니다.

예를 들어 악의적으로 다음 폼을 사용해서 JSON으로 CSRF 공격을 시도할 수도 있습니다:

**CSRF with JSON form**

```html

<form action="https://bank.example.com/transfer" method="post" enctype="text/plain">
  <input
      name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"'
      value='test"}' type='hidden'>
  <input type="submit" value="Win Money!"/>
</form>
```

위의 폼은 아래와 같은 JSON을 만들어 냅니다.

**CSRF with JSON request**

```json
{
  "amount": 100,
  "routingNumber": "evilsRoutingNumber",
  "account": "evilsAccountNumber",
  "ignore_me": "=test"
}
```

만약 애플리케이션에서 Content-Type을 검증하지 않았다면 바로 취약점 공격에 노출됩니다. Spring MVC 애플리케이션에서는 Content-type에서 검증하더라도,
설정에 따라 다음과 같이 `.json` 으로 끝나는 URL에서는 여전히 공격에 취약할 수 있습니다.

**CSRF with JSON Spring MVC form**

```html

<form action="https://bank.example.com/transfer.json" method="post" enctype="text/plain">
  <input
      name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"'
      value='test"}' type='hidden'>
  <input type="submit" value="Win Money!"/>
</form>
```

### CSRF and Stateless Browser Applications

만약 Application이 stateless 즉, 상태가 없다면 어떨까요? 꼭 안전하다고만 할 수는 없습니다. 사실상, 사용자가 웹 브라우저 요청으로 수행하는 작업이 없다
할지라도, CSRF 공격에 노출되어 있는 것은 동일합니다.

예를들어, 인증을 위한 모든 상태를 JSESSIONID 대신 커스텀 쿠키에 저장하는 애플리케이션이라고 가정해보겠습니다. CSRF 공격을 받으면 이전 예제와 같이 JSESSIONID
쿠키가 전송된 것과 같이 요청에 커스텀 쿠키를 포함하여 전송할 것입니다. 이런 애플리케이션은 CSRF 공격에 취약합니다.

기본 인증을 사용하는 애플리케이션 또한 CSRF 공격에 노출되어있습니다. 이전 예제에서 JSESSIONID 쿠키가 전송된 것과 동일하게 브라우저가 모든 요청에 사용자 이름과
비밀번호를 추가하기 때문입니다.

### CSRF Considerations

CSRF 공격에 대한 방어를 구현할 때 몇가지 특별히 고려해야하는 사항이 존재합니다.

### Logging In

[로그인 요청 위조](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests) 를 막으려면
HTTP 요청을 CSRF 공격으로부터 보호해야 합니다. 악의적인 사용자로부터 사용자의 민감한 정보를 읽지 못하도록 로그인 요청 위조는 반드시 막아야합니다. 공격은 다음과 같이
이루어집니다 :

- 악의적인 사용자가 자신의 사용자 인증정보를 사용하여 CSRF 로그인을 수행합니다. 이제 피해자는 악의적인 사용자 계정으로 인증되었습니다.
- 악의적인 사용자는 트릭을 사용하여 피해자가 취약한 사이트에 방문하고, 민감한 정보를 입력하게 만듭니다.
- 위 피해자의 민감한 정보는 악의적인 사용자 계정에서 작성된 정보이기 때문에 악의적인 사용자는 자기 credential로 로그인 한 뒤 피해자의 민감한 정보를 조회할 수
  있습니다.

로그인 HTTP 요청을 CSRF로부터 보호한 뒤 이후에 생길 수 있는 문제는, 세션이 타임아웃되면 사용자가 요청을 거절당해 불편함을 겪을 수 있다는 점입니다. 로그인할 때 세션이
필요하다는 것을 모르는 사용자에게 세션 타임아웃은 당황스러울 것입니다. 자세한
정보는 [CSRF and Session Timeouts](https://docs.spring.io/spring-security/reference/features/exploits/csrf.html#csrf-considerations-timeouts) 을
참고하세요.

### Logging Out

로그아웃 요청 위조를 막으려면 로그아웃 HTTP 요청을 CSRF 공격으로부터 보호해야 합니다. 로그아웃 요청 위조를 보호하는 것은 악의적인 사용자가 피해자의 민감한 정보를 읽을 수
없어야 하기 때문에 반드시 필요합니다. 공격에 대한 자세한
내용은 [https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/](https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/) 
를 참고하세요.

로그아웃 HTTP 요청을 CSRF로부터 보호한 뒤 이후에 생길 수 있는 문제는, 세션이 타임아웃되면 사용자가 요청을 거절당해 불편함을 겪을 수 있다는 점입니다. 로그아웃할 때
세션이 필요하다는 것을 모르는 사용자에게 세션 타임아웃은 당황스러울 것입니다. 자세한
정보는 [CSRF and Session Timeouts](https://docs.spring.io/spring-security/reference/features/exploits/csrf.html#csrf-considerations-timeouts) 을
참고하세요.

### CSRF and Session Timeouts

예상되는 CSRF Token은 세션에 저장되는 경우가 많습니다. 이말인즉슨 세션이 만료하는 즉시 서버에선 CSRF 토큰값을 조회할 수 없으며, HTTP 요청이 거절된다는 것을
의미합니다. 타임아웃을 해결할 수 있는 방법은 여러가지가 존재하며, 각각의 장단점이 있습니다.

- 타임아웃 문제를 줄일 수 있는 가장 좋은 방법은 요청하는 폼을 제출할 때 JavaScript를 사용하여로 CSRF 토큰을 요청하는 것입니다. 이렇게 하면, CSRF 토큰을 폼에
  업데이트하고 제출할 수 있습니다.
- 또 다른 방법으로는 JavaScript로 사용자에게 세션이 만료됨을 알려주는 것입니다. 사용자가 버튼을 클릭하여 세션이 만료되지 않도록 기간을 연장할 수 있습니다.
- 마지막으로 CSRF 토큰을 쿠키에 저장할 수 있습니다. 이렇게 하면 CSRF 토큰이 세션보다 더 오래 지속됩니다.

왜 CSRF 토큰을 기본적으로 쿠키에 저장하지 않는지 궁금할 수 있습니다. 이 이유는 헤더(이를테면, 쿠키를 지정하는 것)를 다른 도메인으로 설정하는 취약점 공격이 알려져있기
때문입니다. Ruby on Rails에서 X-Requested-With Header가 있으면 CSRF 검사를 건너뛰지 않는 것도 같은 이유입니다. 또다른 이유는 상태를 제거하면
CSRF 토큰이 손상됐을 때 강제로 종료할 수 없기 때문입니다.

### Multipart (file upload)

CSRF 공격으로부터 멀티파트 요청을 보호하려고
할땐 [chicken and the egg](https://en.wikipedia.org/wiki/Chicken_or_the_egg) (닭이 먼저인가, 달걀이 먼저인가) 문제가
발생합니다. CSRF 공격을 막기 위해선, HTTPS 요청의 Body를 읽어 실제 CSRF 토큰을 확인해야합니다. 하지만 body를 읽는다는 것 자체가 파일이 업로드된다는 의미기
때문에, 외부 사이트에서도 파일을 업로드할 수 있습니다.

multipart/form-data에서 CSRF 공격을 방어할 수 있는 방법은 2가지가 존재하며, 2가지 각각 장단점이 존재합니다.

- Place CSRF Token in the Body
- Place CSRF Token in the URL

<aside>
💡 Spring Security의 CSRF 방어와 멀티파트 파일 업로드를 통합하기 전, CSRF 방어 없이 업로드가 잘되는지 확인하세요. 멀티파트 폼을 사용하는 방법은 [Multipart Resolver](https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart) 섹션을 참고하거나, [MultipartFilter Javadoc](https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html) 을 참고하세요.

</aside>

### Place CSRF Tokein in the Body

첫 번째 방법은 Request Body에 실제 CSRF 토큰을 추가하는 방법입니다. CSRF 토큰을 Body에 넣으면 Body를 읽고 나서 권한을 부여합니다. 이말인즉슨 누구든지
서버에 임시 파일을 만들 수 있다는 뜻입니다. 하지만 결국엔 인가된 사용자가 제출한 파일만 처리됩니다. 임시 파일 업로드가 서버에 주는 영향은 거의 무시해도 될 수준이기 때문에
일반적으로 권장하는 방법입니다.

### **Include CSRF Token in URL**

권한이 없는 사용자가 임시 파일을 업로드 하는 것이 불가능하다면, 폼의 action 속성에 쿼리 파라미터로 CSRF 토큰을 넣는 것도 방법입니다. 쿼리 파라미터가 유출될 수 있다는
단점을 가지고 있습니다. 떄문에, 민감한 정보를 유출하지 않는 좀 더 일반적인 관행은 body나 header에 두는 것입니다. 자세한
정보는 [RFC 2616 Section 15.1.3 Encoding Sensitive Inforamation in URI’s](https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3) 
를 확인하세요.

### HiddenHttpMethodFilter

일부 애플리케이션에선 폼 파라미터로 HTTP 메서드를 재정의하기도 합니다. 예를들어, 아래 폼은 `POST` 가 아닌 `DELETE` 메서드를 사용하여 제출하는 폼입니다.

**CSRF Hidden HTTP Method Form**