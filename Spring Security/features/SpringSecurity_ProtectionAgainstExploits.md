# Protection Against Exploits

## 😀 Cross Site Request Forgery (CSRF)

Spring은 사이트 간 요청 위조(이하, CSRF) 공격에 대한 방어를 종합적으로 지원합니다.

### What is a CSRF Attack?

CSRF 공격을 이해하려면 예시를 보는 것이 가장 좋습니다.

현재 로그인 된 계정에서 다른 은행 계좌로 돈을 송금하는 웹사이트를 만든다고 가정해보겠습니다.

다음과 같이 송금 폼을 제공합니다:

**Transfer form**

```html

<form method="post" action="/transfer">
  <input type="text" name="amount"/>
  <input type="text" name="routingNumber"/>
  <input type="text" name="account"/>
  <input type="submit" value="Transfer"/>
</form>
```

이 폼을 전송하면 HTTP 요청은 아래와 같을 것입니다:

**Transfer HTTP Request**

```
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876
```

이제 은행 웹사이트에서 인증 후, 로그아웃하지 않고 악의적인 웹사이트에 방문했다고 가정해보겠습니다.

악의적인 웹사이트의 HTML 페이지 폼은 아래와 같습니다:

**Evil transfer form**

```html

<form method="post" action="https://bank.example.com/transfer">
  <input type="hidden" name="amount" value="100.00"/>
  <input type="hidden" name="routingNumber" value="evilsRoutingNumber"/>
  <input type="hidden" name="account" value="evilsAccountNumber"/>
  <input type="submit" value="Win Money!"/>
</form>
```

돈을 준다고 해서, 당신은 제출 버튼을 눌렀습니다. 이 과정에서, 당신은 100달러를 악의적인 사용자에게 송금하였습니다. 이 것이 가능한 이유는 악의적인 사용자가 당신의 쿠키를
조회할 수는 없지만, 앞서 로그아웃하지 않은 은행 웹사이트에서의 쿠키도 악의적인 웹사이트에서 제출버튼과 함께 포함되었기 떄문입니다.

아직 끝나지 않았습니다. 이전체의 프로세스를 JavaScript를 사용하여 전부 자동화했을 수도 있습니다. 그 말인즉슨, 당신이 제출버튼을 클릭하지 않았다는 것을 의미합니다.
게다가, 당신이 정직한 웹사이트 즉, 원래의 은행 웹사이트를 방문했다고
할지라도, [XSS 공격](https://owasp.org/www-community/attacks/xss/) 의 표적이 되면 똑같이 쉽게 재현할 수 있습니다.

그럼 어떻게 해야 이러한 공격으로부터 사용자를 보호할 수 있을까요?

### Protecting Against CSRF attacks

CSRF 공격이 가능한 이유는 공격받는 웹사이트의 HTTP 요청과 공격하는 웹사이트의 요청이 정확하게 동일하기 때문입니다. 그 말인즉슨, 악의적인 웹사이트의 요청은 거절하고 은행
웹사이트의 요청 만을 수락하게 할 수 있는 방법이 명확하지 않다는 것을 의미합니다. 이러한 악의적인 CSRF 공격을 방어하려면, 악의적인 사이트에서 제공할 수 없는 무언가를 요청에
포함해서, 악의적인 요청과 일반적인 요청 이 두가지를 구분할 수 있어야합니다.

Spring은 CSRF 공격을 방어할 수 있는 2가지 매커니즘을 제공합니다:

- The [Synchronizer Token Pattern](https://www.notion.so/Protection-Against-Exploits-7f346a46014043e3a46630128d869aef)
- Specifying the [SameSite Attribute](https://docs.spring.io/spring-security/reference/features/exploits/csrf.html#csrf-protection-ssa) on your session cooke

>💡 위의 두가지 매커니즘 모두 Safe Method는 반드시 멱등성을 보장해야 합니다.



### Safe Methods Must be Idempotent

CSRF 공격을 방어하는 위의 두가지 매커니즘이 잘 동작하려면 “safe”HTTP 메서드는 모두 멱등성을 보장해야합니다. 즉, HTTP 메서드 `GET`, `HEAD`
, `OPTIONS`, `TRACE` 요청은 애플리케이션 상태를 변화시키면 안됩니다.

### Synchronizer Token Pattern

CSRF 공격을 방어하는 방법은 Synchronizer Token Pattern이 지배적이며, 가장 포괄적입니다. 이 솔루션은 HTTP 요청에 세션 쿠키와는 별개로 CSRF
Token이라 불라는 Secure random(안전한 난수)을 생성하여, 이를 우리의 각 HTTP 요청에 저장합니다.

여기서 중요한 키 포인트는 HTTP 요청에 브라우저가 자동으로 이 값을 넣어주는 것이 아닌 CSRF 토큰이 있어야 한다는 것입니다. 예를 들어, HTTP 파라미터나 헤더에서
CSRF 토큰을 받으면 CSRF 공격을 방어할 수 있습니다. 쿠키는 브라우저가 HTTP 요청에 자동으로 포함시키기 때문에, CSRF 토큰을 쿠키에서 받으면 의미가 없습니다.

아래의 예제를 통해 Synchronizer Token Pattern을 사용하면 어떻게 바뀌는지 살펴봅시다. CSRF 토큰은 `_csrf` 이라는 이름으로 HTTP 파라미터로
받는다고 가정합시다.

애플리케이션의 송금 폼은 아래와 같습니다:

**Synchronizer Token Form**

```html

<form method="post" action="/transfer">
  <input type="hidden" name="_csrf" value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
  <input type="text" name="amount"/>
  <input type="text" name="routingNumber"/>
  <input type="hidden" name="account"/>
  <input type="submit" value="Transfer"/>
</form>
```

이제 폼은 hidden input 타입의 _csrf 필드에 CSRF Token 값을 가지고 있습니다. 외부 사이트에서는 동일 출처 정책에 따라 응답을 읽을 수 없기 때문에,
CSRF를 읽어갈 수 없습니다.

이에 따른 돈을 송금하는 HTTP 요청은 아래와 같습니다:

**Synchronizer Token request**

```
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876&**_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721**
```

CSRF TOKEN을 통해, HTTP요청에 CSRF 토큰의 값으로 안전한 난수가 들어있습니다. 악의적인 웹사이트에서는 CSRF 토큰 값을 정확하게 작성할 수 없으며, 서버에서
가지고 있는 CSRF 토큰과 실제 요청에 있는 CSRF 토큰이 일치해야 하기 때문에, CSRF 공격으로부터 안전해졌습니다.

### SameSite Attribute

최근에 생겨난 다른 CSRF 공격에 대한 방어 방법으로 `SameSite` 속성을 지정하는 방법이 있습니다. 서버는 외부 사이트가 보내는 요청엔 쿠키를 사용하지
않겠다고 `SameSite` 속성을 지정함으로써 이를 명시할 수 있습니다.

>💡 Spring Security는 세션 쿠키의 생성을 직접 제어하지 않기 때문에, `SamiteSite` 속성을 지원하지 않습니다.  서블릿 기반 애플리케이션에서 `Spring Session`은 `SameSite` 속성을 제공합니다. WebFlux 기반 애플리케이션에서는 Spring Framework의 [CookieWebSessionIdResolver](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/session/CookieWebSessionIdResolver.html) 가 전용 `SameSite` 속성을 지원합니다.



HTTP 응답 헤더에서 `SameSite` 속성을 사용하는 경우의 예시는 아래와 같습니다.

**SameSite HTTP response**

```
Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax
```

**SameSite** 속성으로 유효한 값은 아래와 같습니다:

- Strict - Strict로 지정할 경우, 동일 사이트가 보내는 모든 요청에 쿠키를 포함시킵니다. 그외의 HTTP 요청에는 쿠키를 추가하지 않습니다.
- Lax - Lax로 지정할 경우, 동일 사이트가 보내는 모든 요청에 쿠키를 포함시킵니다. 또는 사이트가 다르더라도, top-level navigation에서
  보낸요청이면서 [멱등성을 보장하는 메서드](https://www.notion.so/Protection-Against-Exploits-7f346a46014043e3a46630128d869aef) 일
  경우, 쿠키를 포함시킵니다. 그 외의 HTTP 요청에는 쿠키를 추가하지 않습니다.

우리의 예제에서 `SameSite` 속성을 사용하여 CSRF 공격으로부터 보호할 수 있는지 알아보겠습니다.

은행 애플리케이션은 세션 쿠키에 `SameSite` 속성을 명시하여 은행 애플리케이션을 CSRF 공격으로부터 방어할 수 있습니다.

`SameSite` 속성을 우리의 세션 쿠키에 설정하면, 브라우저는 은행 웹사이트로부터 오는 모든 요청에 `JSESSIONID`를 계속적으로 보냅니다. 그러나, 브라우저가 악의적인
웹사이트로부터 오는 요청에는 더 이상 `JSESSIONID`를 보내지 않습니다. 악의적인 웹사이트에서 보내는 송금 요청에는 더이상 세션이 존재하지 않기때문에(JSESSIONID가
없어서), CSRF 공격으로부터 애플리케이션을 보호할 수 있습니다.

여기에는 SameSite 속성을 사용하여 CSRF 공격을 방어할 때 꼭 알아둬야할 주의 사항이 있습니다.

`SameSite` 속성을 `Strict`로 지정하는 것이 보다 안전하지만, 사용자를 혼란스럽게 할 수 있습니다. 사용자가 https://social.example.com에서
호스팅하는 SNS에 로그인한 상태라고 가정해보겠습니다. 사용자는 https://email.example.org에서 이 SNS 사이트로 가는 링크가 적힌 이메일 하나를
전달받았습니다. 사용자는 이 링크를 클릭하면 당연히 SNS 사이트로 정상적으로 이동할 것이라고 생각하지만, `SameSite` 속성이 `Strict` 이기때문에 쿠키를 전송하지
않아 사용자를 인증할 수 없습니다.

>💡 [gh-7537](https://github.com/spring-projects/spring-security/issues/7537) 을 구현하면 보안을 강화하면서도 CSRF 공격 방어를 위한 `SameSite` 사용성을 개선할 수 있습니다.



또다른 주의해야할 점은, `SameSite` 속성으로 사용자를 보호하기 위해선, 브라우저는 반드시 `SameSite` 속성을 지원해야합니다. 대부분의 모던
브라우저들은 `SameSite` 속성을 지원합니다. 오래된 브라우저들은 이를 지원하지 않을 수도 있습니다.

### When to use CSRF protection

그러면 CSRF 방어는 어떨 때 사용해야 할까요? 우리는 일반 사용자가 브라우저에서 처리할 수 있는 모든 요청에 CSRF 방어를 적용하는 것을 권고합니다. 만약 만들고 있는
서비스를 브라우저가 아닌 클라이언트에서만 사용한다면 CSRF 방어를 비활성화하셔도 됩니다.

### CSRF protection and JSON

흔히 하는 질문으로 “javascript에서 만든 JSON 요청도 방어해야하나요?”라고 묻곤합니다. 짧게 대답하자면, 떄에 따라 다릅니다. 그러나, JSON 요청또한 CSRF
취약점에 매우 주의해야합니다.

예를 들어 악의적으로 다음 폼을 사용해서 JSON으로 CSRF 공격을 시도할 수도 있습니다:

**CSRF with JSON form**

```html

<form action="https://bank.example.com/transfer" method="post" enctype="text/plain">
  <input
      name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"'
      value='test"}' type='hidden'>
  <input type="submit" value="Win Money!"/>
</form>
```

위의 폼은 아래와 같은 JSON을 만들어 냅니다.

**CSRF with JSON request**

```json
{
  "amount": 100,
  "routingNumber": "evilsRoutingNumber",
  "account": "evilsAccountNumber",
  "ignore_me": "=test"
}
```

만약 애플리케이션에서 Content-Type을 검증하지 않았다면 바로 취약점 공격에 노출됩니다. Spring MVC 애플리케이션에서는 Content-type에서 검증하더라도,
설정에 따라 다음과 같이 `.json` 으로 끝나는 URL에서는 여전히 공격에 취약할 수 있습니다.

**CSRF with JSON Spring MVC form**

```html

<form action="https://bank.example.com/transfer.json" method="post" enctype="text/plain">
  <input
      name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"'
      value='test"}' type='hidden'>
  <input type="submit" value="Win Money!"/>
</form>
```

### CSRF and Stateless Browser Applications

만약 Application이 stateless 즉, 상태가 없다면 어떨까요? 꼭 안전하다고만 할 수는 없습니다. 사실상, 사용자가 웹 브라우저 요청으로 수행하는 작업이 없다
할지라도, CSRF 공격에 노출되어 있는 것은 동일합니다.

예를들어, 인증을 위한 모든 상태를 JSESSIONID 대신 커스텀 쿠키에 저장하는 애플리케이션이라고 가정해보겠습니다. CSRF 공격을 받으면 이전 예제와 같이 JSESSIONID
쿠키가 전송된 것과 같이 요청에 커스텀 쿠키를 포함하여 전송할 것입니다. 이런 애플리케이션은 CSRF 공격에 취약합니다.

기본 인증을 사용하는 애플리케이션 또한 CSRF 공격에 노출되어있습니다. 이전 예제에서 JSESSIONID 쿠키가 전송된 것과 동일하게 브라우저가 모든 요청에 사용자 이름과
비밀번호를 추가하기 때문입니다.

### CSRF Considerations

CSRF 공격에 대한 방어를 구현할 때 몇가지 특별히 고려해야하는 사항이 존재합니다.

### Logging In

[로그인 요청 위조](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests) 를 막으려면
HTTP 요청을 CSRF 공격으로부터 보호해야 합니다. 악의적인 사용자로부터 사용자의 민감한 정보를 읽지 못하도록 로그인 요청 위조는 반드시 막아야합니다. 공격은 다음과 같이
이루어집니다 :

- 악의적인 사용자가 자신의 사용자 인증정보를 사용하여 CSRF 로그인을 수행합니다. 이제 피해자는 악의적인 사용자 계정으로 인증되었습니다.
- 악의적인 사용자는 트릭을 사용하여 피해자가 취약한 사이트에 방문하고, 민감한 정보를 입력하게 만듭니다.
- 위 피해자의 민감한 정보는 악의적인 사용자 계정에서 작성된 정보이기 때문에 악의적인 사용자는 자기 credential로 로그인 한 뒤 피해자의 민감한 정보를 조회할 수
  있습니다.

로그인 HTTP 요청을 CSRF로부터 보호한 뒤 이후에 생길 수 있는 문제는, 세션이 타임아웃되면 사용자가 요청을 거절당해 불편함을 겪을 수 있다는 점입니다. 로그인할 때 세션이
필요하다는 것을 모르는 사용자에게 세션 타임아웃은 당황스러울 것입니다. 자세한
정보는 [CSRF and Session Timeouts](https://docs.spring.io/spring-security/reference/features/exploits/csrf.html#csrf-considerations-timeouts) 을
참고하세요.

### Logging Out

로그아웃 요청 위조를 막으려면 로그아웃 HTTP 요청을 CSRF 공격으로부터 보호해야 합니다. 로그아웃 요청 위조를 보호하는 것은 악의적인 사용자가 피해자의 민감한 정보를 읽을 수
없어야 하기 때문에 반드시 필요합니다. 공격에 대한 자세한
내용은 [https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/](https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/) 
를 참고하세요.

로그아웃 HTTP 요청을 CSRF로부터 보호한 뒤 이후에 생길 수 있는 문제는, 세션이 타임아웃되면 사용자가 요청을 거절당해 불편함을 겪을 수 있다는 점입니다. 로그아웃할 때
세션이 필요하다는 것을 모르는 사용자에게 세션 타임아웃은 당황스러울 것입니다. 자세한
정보는 [CSRF and Session Timeouts](https://docs.spring.io/spring-security/reference/features/exploits/csrf.html#csrf-considerations-timeouts) 을
참고하세요.

### CSRF and Session Timeouts

예상되는 CSRF Token은 세션에 저장되는 경우가 많습니다. 그 말인즉슨 세션이 만료하는 즉시 서버에선 CSRF 토큰값을 조회할 수 없으며, HTTP 요청이 거절된다는 것을
의미합니다. 타임아웃을 해결할 수 있는 방법은 여러가지가 존재하며, 각각의 장단점이 있습니다.

- 타임아웃 문제를 줄일 수 있는 가장 좋은 방법은 요청하는 폼을 제출할 때 JavaScript를 사용하여로 CSRF 토큰을 요청하는 것입니다. 이렇게 하면, CSRF 토큰을 폼에
  업데이트하고 제출할 수 있습니다.
- 또 다른 방법으로는 JavaScript로 사용자에게 세션이 만료됨을 알려주는 것입니다. 사용자가 버튼을 클릭하여 세션이 만료되지 않도록 기간을 연장할 수 있습니다.
- 마지막으로 CSRF 토큰을 쿠키에 저장할 수 있습니다. 이렇게 하면 CSRF 토큰이 세션보다 더 오래 지속됩니다.

왜 CSRF 토큰을 기본적으로 쿠키에 저장하지 않는지 궁금할 수 있습니다. 이 이유는 헤더(이를테면, 쿠키를 지정하는 것)를 다른 도메인으로 설정하는 취약점 공격이 알려져있기
때문입니다. Ruby on Rails에서 X-Requested-With Header가 있으면 CSRF 검사를 건너뛰지 않는 것도 같은 이유입니다. 또다른 이유는 상태를 제거하면
CSRF 토큰이 손상됐을 때 강제로 종료할 수 없기 때문입니다.

### Multipart (file upload)

CSRF 공격으로부터 멀티파트 요청을 보호하려고
할땐 [chicken and the egg](https://en.wikipedia.org/wiki/Chicken_or_the_egg) (닭이 먼저인가, 달걀이 먼저인가) 문제가
발생합니다. CSRF 공격을 막기 위해선, HTTPS 요청의 Body를 읽어 실제 CSRF 토큰을 확인해야합니다. 하지만 body를 읽는다는 것 자체가 파일이 업로드된다는 의미기
때문에, 외부 사이트에서도 파일을 업로드할 수 있습니다.

multipart/form-data에서 CSRF 공격을 방어할 수 있는 방법은 2가지가 존재하며, 2가지 각각 장단점이 존재합니다.

- Place CSRF Token in the Body
- Place CSRF Token in the URL

>💡 Spring Security의 CSRF 방어와 멀티파트 파일 업로드를 통합하기 전, CSRF 방어 없이 업로드가 잘되는지 확인하세요. 멀티파트 폼을 사용하는 방법은 [Multipart Resolver](https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart) 섹션을 참고하거나, [MultipartFilter Javadoc](https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html) 을 참고하세요.



### Place CSRF Tokein in the Body

첫 번째 방법은 Request Body에 실제 CSRF 토큰을 추가하는 방법입니다. CSRF 토큰을 Body에 넣으면 Body를 읽고 나서 권한을 부여합니다. 그 말인즉슨 누구든지
서버에 임시 파일을 만들 수 있다는 뜻입니다. 하지만 결국엔 인가된 사용자가 제출한 파일만 처리됩니다. 임시 파일 업로드가 서버에 주는 영향은 거의 무시해도 될 수준이기 때문에
일반적으로 권장하는 방법입니다.

### **Include CSRF Token in URL**

권한이 없는 사용자가 임시 파일을 업로드 하는 것이 불가능하다면, 폼의 action 속성에 쿼리 파라미터로 CSRF 토큰을 넣는 것도 방법입니다. 쿼리 파라미터가 유출될 수 있다는
단점을 가지고 있습니다. 떄문에, 민감한 정보를 유출하지 않는 좀 더 일반적인 관행은 body나 header에 두는 것입니다. 자세한
정보는 [RFC 2616 Section 15.1.3 Encoding Sensitive Inforamation in URI’s](https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3) 
를 확인하세요.

### HiddenHttpMethodFilter

일부 애플리케이션에선 폼 파라미터로 HTTP 메서드를 재정의하기도 합니다. 예를들어, 아래 폼은 `POST` 가 아닌 `DELETE` 메서드를 사용하여 제출하는 폼입니다.

**CSRF Hidden HTTP Method Form**
```html
<form action="/process" method="post">
	<!-- ... -->
	<input type="hidden" name="_method" value="delete"/>
</form>
```

HTTP 메서드 재 정의는 필터에서 발생합니다. 이 필터는 반드시 Spring Security 필터가 동작하기 이전에 처리되어야 합니다. 물론 `POST` 에서만 일어나기 때문에 실제로 문제가 되지는 않습니다. 하지만, Spring Security 필터보다 앞에 두는 것이 가장 좋은 방법입니다.

## 😀 HTTP Headers

>💡 이번에 다룰 주제는 보안 HTTP 응답 헤더에 관한 일반적인 내용입니다. Servlet 과 WebFlux 기반의 애플리케이션에서 필요한 보안 헤더 정보는 이 섹션을 참고하세요.



많은 HTTP 응답 헤더는 웹 애플리케이션의 보안을 강화하는데 사용할 수 있습니다. 이번 섹션에서는 다양한 HTTP 응답헤더를 통해 Spring Security가 제공하는 취약점 지원점에 대해 다룰 것입니다. 필요에 따라, Spring Security는 Custom header를 설정할 수도 있습니다.

### Default Security Headers

>💡 Servlet 과 WebFlux 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.



Spring Security는 기본 보안에 해당하는 HTTP 응답헤더와 연관된 보안 기본 셋을 제공합니다.

아래에 나열된 헤더는 Spring Seucirty의 기본값에 해당합니다:

**Default Security HTTP Response Headers**

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

>💡 위의 예시에서 Strict-Transport-Security는 HTTPS 요청에서만 추가됩니다.



만약 디폴트 헤더 만으로 부족하다면, 간단히 디폴트 헤더를 제거, 수정하거나 새로운 헤더를 추가할 수 있습니다. 각 헤더에 대한 자세한 설명은 해당 섹션을 참고하세요:

- Cache Control
- Content Type Options
- HTTP Strict Transport Security
- X-Frame-Options
- X-XSS-Protection

---

### Cache Control

>💡 [Servlet](https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-permissions) 과 [WebFlux](https://docs.spring.io/spring-security/reference/reactive/exploits/headers.html#webflux-headers-permissions) 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.



Spring Security의 기본값은 사용자의 컨텐츠를 보호하기 위해, Cache를 비활성화 하는 것입니다. 만약 민감한 정보 조회 권한을 인가받은 사용자가 로그아웃하였을 때, 악의적인 사용자가 뒤로가기 버튼을 클릭하여 민감한 정보가 볼 수 없도록하기 위해서입니다.

**Default Cache Control HTTP Response Headers**

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
```

이러한 보안상의 이유로 Spring Security에서는 이를 기본값으로 헤더에 작성합니다. 그러나, 애플리케이션 자체에서 Cache Control을 사용한다면 Spring Security는 이 기본 헤더값을 작성하지 않습니다. 이를 통해, 애플리케이션은 CSS나 JavaScript와 같은 정적 리소스를 캐시할 수 있습니다.

### Content Type Options

>💡 [Servlet](https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-permissions) 과 [WebFlux](https://docs.spring.io/spring-security/reference/reactive/exploits/headers.html#webflux-headers-permissions) 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.



역사적으로 Internet Explorer 외 많은 브라우저들은 [content sniffing](https://en.wikipedia.org/wiki/Content_sniffing) 을 사용하여 요청의 컨텐츠 타입을 추측해왔습니다. 이처럼 브라우저가 컨텐츠 타입을 명시하지 않은 리소스의 컨텐츠 타입을 추측하기 때문에 사용자는 좀 더 나은 경험을 할 수 있습니다. 예를들어, 만약 브라우저가 컨텐츠 타입이 명시되지 않은 JavaScript File를 맞닥뜨리면 컨텐츠 타입을 추론한 다음 실행합니다.

>💡 컨텐츠 업로드를 허용하면 추가로 해야할 것들이 많습니다.(별도 도메인에서 문서를 노출하고, 컨텐츠 타입 헤더가 추가되었는지 검증하고, 유해 컨텐츠를 삭제하는 등..) 그러나 이러한 조치는 Spring Security가 제공하는 범위를 벗어납니다. content sniffing을 비활성화한다면 반드시 컨텐츠 타입을 지정해야 정상적으로 동작한다는 것도 주의해야 합니다.



content sniffing의 문제점은 악의적인 사용자가 다국어(예를들어, 여러 content type에서 유효한 파일)를 사용해 XSS 공격을 할 수 있다는 점입니다. 예를 들어, 사용자가 후기를 작성하고 이를 열람할 수 있는 웹사이트가 있다고 해보겠습니다. 악의적인 사용자는 [자바스크립트 파일을 후기로 작성](http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf) 하여 XSS 공격을 시도할 수 있습니다.

Spring Security는 기본값으로 HTTP 응답에 헤더를 추가하여 content sniffing을 비활성화할 수 있습니다:

```
X-Content-Type-OPtions: nosniff
```

### HTTP Strict Transport Security (HSTS)

>💡 [Servlet](https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-permissions) 과 [WebFlux](https://docs.spring.io/spring-security/reference/reactive/exploits/headers.html#webflux-headers-permissions) 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.



은행 웹사이트를 방문하려고합니다. 은행 웹사이트의 주소를 직접 주소창에 작성하여 접근한다면, mybank.example.com과 같이 접근합니다. 프로토콜을 생략하는 경우가 많습니다. 이렇게 된다면 누군가가 http 요청을 가로채서 악의적인 은행 웹사이트로 리다이렉트 할 수도 있습니다.([중간자 공격](https://en.wikipedia.org/wiki/Man-in-the-middle_attack))

https 프로토콜을 생략하고 웹사이트에 접근하는 사용자가 많아 [HTTP Strict Transport Security (HSTS)](https://datatracker.ietf.org/doc/html/rfc6797) 가 생겨났습니다. mybank.example.com 이 HSTS 호스트에 추가되면 브라우저는 mybank.example.com 로 접근할 때 https://mybank.example.com 으로 해석해야한 다는 것을 미리 알 수 있습니다.

이로써 중간자 공격을 받을 수 있는 가능성이 많이 줄어들게 됩니다.

>💡 [RFC6797](https://datatracker.ietf.org/doc/html/rfc6797#section-7.2)에 따르면 HTTPS 응답에만 HSTS 헤더를 추가합니다. 브라우저가 헤더를 인식하려면 먼저 브라우저가 신뢰할 수 있는 CA에서 서명한 SSL 인증서(즉, 공인 인증서)로 커넥션을 맺어야 합니다.



사이트를 HSTS 호스트로 표시하는 한가지 방법은 브라우저에 미리 호스트를 로드하는 것입니다. 또다른 방법으로는 `Strict-Transport-Security` 헤더를 응답에 추가하는 것입니다. 에를 들어, Spring Securirty의 기본 행동은 아래의 헤더를 추가하여 1년간 이 도메인을 HSTS 호스트로 인식하도록 하는 것입니다.

**Strict Transport Security HTTP Response Header**

```
Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload
```

선택 값(Optional)인 **includeSubDomains**은 브라우저에게 하위 도메인 또한 HSTS 도메인으로 다루어야한다고 명시하는 지시문입니다.

선택 값(Optional)인 preload는 도메인을 미리 HSTS 도메인으로 사전에 로드하도록하는 지시문입니다. HSTS preload에 대한 자세한 사항은 [https://hstspreload.org/](https://hstspreload.org/)을 참고하세요.

### HTTP Public Key Pinning (HPKP)

>💡 Spring Secirty는 HPKP를 하위 호환성을 위해 아직까지 지원하고 있지만 위의 내용의 이유로 더이상 HPKP 사용을 권고하지 않습니다.



[HTTP Public Key Pinning (HPKP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning) 은 특정 웹 서버에서 사용할 공개키를 웹 클라이언트에서 지정하는 방식으로, 위조 인증서를 사용하는 중간자(MITM) 공격을 방어합니다. HPKP를 정확히 사용한다면 인증서 손상을 막기 위한 레이어가 추가되어야 합니다. 그러나 HPKP의 복장성으로 ㅇ니해 많은 전문가들은 더이상 사용하지 않기를 권고하고 있으며, [Chrome은 이것에 대한 지원을 종료](https://www.chromestatus.com/feature/5903385005916160)하였습니다.

HPKP에대한 추가적인 정보가 필요하다면 [Is HTTP Public Key Pinning Dead?](https://blog.qualys.com/ssllabs/2016/09/06/is-http-public-key-pinning-dead) 와 [I’m giving up on HPKP](https://scotthelme.co.uk/im-giving-up-on-hpkp/) 를 확인하세요.

### X-Frame-Options

>💡 [Servlet](https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-permissions) 과 [WebFlux](https://docs.spring.io/spring-security/reference/reactive/exploits/headers.html#webflux-headers-permissions) 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.



Frame에 웹사이트를 추가하는 것에 대한 보안 이슈가 존재합니다. 예를 들어, CSS를 잘 활용하는 사용자는 무언가 클릭했을 때 의도하지 않은 동작을 수행시키게 할 수 있습니다. 예를들어 은행 웹사이트에 로그인한 사용자가 버튼을 클릭하면 다른 사용자에게 권한이 부여되도록할 수 있습니다. 이런 종류의 공격을 [Clickjacking](https://en.wikipedia.org/wiki/Clickjacking) 이라고 합니다.

>💡 Clickjacking을 해결하는 또다른 근래 방법으로는 [Content Security Policy(CSP)](https://docs.spring.io/spring-security/reference/features/exploits/headers.html#headers-csp) 도 사용됩니다.



Clickjacking을 막는 방법은 여러가지가 있습니다. 예를들어, 레거시(구 버전의) 브라우저에서  [frame breaking code](https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script) 을 사용하여 Clickjacking 공격을 막을 수 있습니다. 완전하지는 않지만, frame breaking code는 레거시 브라우저에서 할 수 있는 최고의 방법 입니다.

Clickjacking을 막는 좀더 최신의 방법은 X-Frame-Options 헤더를 사용하는 것입니다. Spring Security는 기본적으로 아래의 헤더를 통해, iframe 내부에 페이지를 렌더링 할 수 업도록 합니다.

```
X-Frame-Options: DENY
```

### X-XSS-Protection

>💡 [Servlet](https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-permissions) 과 [WebFlux](https://docs.spring.io/spring-security/reference/reactive/exploits/headers.html#webflux-headers-permissions) 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.



몇몇 브라우저에서는 [relected XSS 공격](https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OWASP-DV-001)) 을 차단하는 것을 지원합니다. 이것만으로 완전히 막을 수는 없지만, XSS 공격을 일차적으로 막을 수 있습니다.

필터링은 통상 기본값으로 활성화 되어있기 때문에 이 헤더를 추가하는 것만으로 확인할 수 있으며, XSS 공격을 감지하였을 때, 뭘 해야할 지 지시할 수 있습니다. 예를 들어, 필터는 모든 것을 렌더링하기 위해 최소한의 침입 방식으로 변경할 수 있습니다. 하지만 이 방식은 컨텐츠 수정 자체가 XSS 취약점이 될 수 있습니다. 컨텐츠를 수정하느 대신 컨텐츠를 막아버리는 편이 더 좋습니다. Spring Security는 기본값으로 다음 헤더를 사용해 컨텐츠의 허용을 제한합니다:

```
X-XSS-Protection: 1; mode=block
```

### Content Security Policy (CSP)

>💡 [Servlet](https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-permissions) 과 [WebFlux](https://docs.spring.io/spring-security/reference/reactive/exploits/headers.html#webflux-headers-permissions) 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.


Content Security Policy(CSP)는 웹 애플리케이션에서 XSS(cross-site scripting)과 같은 컨텐츠 인젝션 취약점들을 개선할 수 있는 매커니즘입니다. CSP는 웹 애플리케이션이 로드할 수 있는 리소스를 개발자가 직접 명시하여 궁극적으로 클라이언트(user-agent)에게 알리는 정책입니다.

>💡 CSP는 모든 인젝션 취약점을 해결해주지는 않습니다. CSP는 컨텐츠 인젝션 공격의 피해를 최소화해 준다고 볼 수 있습니다. 일차적인 방어책은 웹 애플리케이션에서의 입력을 검증하고 인코딩하는 것입니다.



웹 애플리케이션에서 CSP를 사용하려면 다음 헤더 중 하나를 HTTP 응답에 추가해야 합니다:

- `Content-Security-Policy`
- `Content-Security-Policy-Report-Only`

각 헤더는 클라이언트에게 보안 정책을 전달하는 매커니즘으로 사용됩니다. 보안 정책은 특정 리소스 표현에 대한 제한을 선언하는 보안 정책 지시문이 포함되어 있습니다.

예를들어 웹 애플리케이션 응답에 다음 헤더를 추가하면, 신뢓ㄹ 수 있는 특정 리소스에서만 스크립트를 로드합니다:

**Content Security Policy Excample**

```
Content-Security-Policy: script-src https://trustedscripts.example.com
```

`srcipt-src` 에 선언한 리소스 외의 다른 리소스에서 스크립트를 로드하려고 하면 이는 `user-agent`에서 차단될 것입니다. 추가로 보안 정책에 [report-uri](https://www.w3.org/TR/CSP2/#directive-report-uri) 를 선언하면 user-agent는 이런 시도가 있을 때 마다 지정 URL에 보고합니다.

예를 들어, 아래의 응답 헤더는 웹 애플리케이션이 선언한 보안 정책을 위반하면, user-agent에 report-uri에 명시한 URL로 보고할 것을 지시합니다.

**Content Security Policy with report-uri**

```
Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/
```

[Violation reports](https://www.w3.org/TR/CSP2/#violation-reports)는 표준 JSON 구조이며, 웹 애플리케이션 자체 API로 수집할 수도 있고, [https://report-uri.com과](https://report-uri.com과) 같은 공개적으로 호스팅되는 CSP violation 리포팅 서비스를 이용할 수도 있습니다.

**`Content-Security-Policy-Report-Only`** 헤더는 보안 정책을 바로 적용하는 대신, 개발자 및 관리자가 보안 정책을 모니터링할 수 있는 것을 제공합니다. 이 헤더는 통상적으로 보안 정책이 실험 및 개발 단계일 때 사용합니다. 이 정책이 효과적이라 판단되면, 이 헤더 대신 `Content-Security-Policy` 헤더 필드를 사용해서 정책을 시행하면 됩니다.

아래의 응답 헤더는 두 시로스 중 하나에서 리소스를 로드할 수 있다는 정책을 선언하는 헤더입니다.

```
Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/
```

evil.com에서 스크립트를 로드하여 위의 정책을 위반하려 하는 것이 감지되면 user-agent는 지정된 URL에 따라 위반에 대한 보고서를 전송하지만, 리소스는 여전히 로드할 수 있습니다.

웹 애플리케이션에 컨텐츠 보안 정책을 적용하기는 쉽지 않을 수도 있습니다. 다음 사이트를 참고하면 효과적으로 보안 정책을 만드는데 조금이나마 도움이 될 것입니다.

- [An Introduction to Content Security Policy](https://www.html5rocks.com/en/tutorials/security/content-security-policy/)
- [CSP Guide - Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/Security/CSP)
- [W3C Candidate Recommendation](https://www.w3.org/TR/CSP2/)

### Referrer Policy

>💡 [Servlet](https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-permissions) 과 [WebFlux](https://docs.spring.io/spring-security/reference/reactive/exploits/headers.html#webflux-headers-permissions) 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.



Servlet 과 WebFlux 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.

[Referrer Policy](https://www.w3.org/TR/referrer-policy) 는  사용자가 마지막으로 방문한 페이지를 가지고 있는 referrer field를 관리할 수 있는 매커니즘입니다.

Spring Security의 방법은 다른 여러 정책을 제공하는 Referrer Policy 헤더를 사용하는 것입니다:

**Referrer Policy Example**

```
Referrer-Policy: same-origin
```

응답 헤더에 Referrer-Policy를 작성하면 브라우저는 사용자가 이전에 방문한 곳을 도착지에 알려줍니다.

### Feature Policy

>💡 [Servlet](https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-permissions) 과 [WebFlux](https://docs.spring.io/spring-security/reference/reactive/exploits/headers.html#webflux-headers-permissions) 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.



[Feature Policy](https://wicg.github.io/feature-policy/)는 웹 개발자가 원하는 대로 특정 API와 브러우저의 웹 기능을 활성 및 비활성화하거나 동작을 수정할 수 있도록 도와줍니다.

**Feature Policy Example**

```
Feature-Policy: geolocation 'self'
```

Feature Policy를 사용하면, 개발자가 브라우저의 “policies” 셋에 관여하여 사이트 전체에서 사용할 특정 기능들을 강제할 수 있습니다. 이 정책들은 사이트에서 특정 기능에 대한 브라우저의 기본 동작에 액세스하거나 수정할 수 있는 API를 제한합니다.

### **Permissions Policy**

>💡 [Servlet](https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-permissions) 과 [WebFlux](https://docs.spring.io/spring-security/reference/reactive/exploits/headers.html#webflux-headers-permissions) 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.



Permissions Policy 는 웹 개발자가 브라우저에서 특정 api 및 웹 기능의 동작을 선택적으로 활성 및 비활성화 그리고 수정할 수 있는 매커니즘입니다.

**Permissions Policy Example**

```
Permissions-Policy: geolocation=(self)
```

Permissions Policy를 통해 개발자는 브라우저가 사이트 전체에서 사용되는 특정 기능에 적용할 “policies”셋을 선택할 수 있습니다. 이러한 정책은 브라우저의 기본 동작에 접근하거나 수정할 수 있는 API를 제한합니다.

### Clear Site Data

>💡 [Servlet](https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-permissions) 과 [WebFlux](https://docs.spring.io/spring-security/reference/reactive/exploits/headers.html#webflux-headers-permissions) 기반 애플리케이션에서 기본 헤더를 어떻게 커스텀하는지에 대한 내용은 이 섹션을 참고하세요.



Claer Site Data 는 HTTP 응답에 이 헤더를 포함하여 쿠키나 로컬스토리지와 같은 브라우저 단 데이터를 삭제할 수 있는 매커니즘입니다.

```
Clear-Site-Data: "cache", "cookies", "storage", "executionContexts"
```

Clear Site Data는 로그아웃 시 데이터를 비우는 용도로 알맞은 작업입니다.

### Custom Headers

>💡 [Servlet](https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-permissions) 기반 애플리케이션을 구성하는 방법에 대한 내용을 보려면 이 섹션을 참고하세요.


Spring Security는 보다 일반적인 보안 헤더를 애플리케이션에 편리하게 추가할 수 있는 메커니즘을 제공합니다. 하지만 커스텀 헤더를 추가할 수 있는 훅도 함께 제공합니다.

## 😀 HTTP

[Static Resources](https://www.troyhunt.com/heres-why-your-static-website-needs-https/) 에 포함되는 모든 HTTP 기반 통신은 [TLS를 사용](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html) 하여 보호해야 합니다.

Spring Security는 Framework로써 HTTP 커넥션을 직접 다루지 않으며 HTTPS를 직접적으로 지원하지 않습니다. 하지만, HTTPS 사용을 도와줄 몇가지 기능을 제공합니다.

### Redirect to HTTPS

클라이언트가 HTTP를 사용할 때, Spring Security는 WebFlux 및 Servlet 환경 모두 HTTPS로 리다이렉트 할 수 있도록 설정할 수 있습니다.

### Strict Transport Security

Spring Security는 [Strict Transport Security](https://docs.spring.io/spring-security/reference/features/exploits/headers.html#headers-hsts) 에 대한 지원을 제공하며 기본적으로 활성화 되어있습니다.

### Proxy Server Configuration

프록시 서버를 사용할 때 중요한 점은 애플리케이션 설정에 문제가 없는지 잘 확인해야합니다. 예를들면, 수많은 애플리케이션은 로드밸런서를 사용하고 있으며, https://example.com 에 들어온 요청을 https://192.168.0.1:8080 에 해당하는 애플리케이션 서버로 전달할 것입니다. 설정을 잘못하면, 애플리케이션 서브는 로드밸런서의 존재를 알지 못하고 클라이언트가 https://192.168.0.1:8080으로의 요청한 것으로 인지할 수 있습니다.

[RFC 7239](https://tools.ietf.org/html/rfc7239)를 사용해서 로드밸런서를 사용 중임을 명시하면 이를 방지할 수 있습니다. 애플리케이션 서버에도 X-Forwarded 류의 헤더를 서버에 설정해줘야 이를 인지할 수 있습니다. 예를 들어 톰캣은 [RemoteIpValve](https://tomcat.apache.org/tomcat-8.0-doc/api/org/apache/catalina/valves/RemoteIpValve.html), Jetty는 [ForwardedRequestCustomizer](https://www.eclipse.org/jetty/javadoc/jetty-9/org/eclipse/jetty/server/ForwardedRequestCustomizer.html) 를 사용합니다. Spring을 사용할 경우 [ForwardedHeaderFilter](https://github.com/spring-projects/spring-framework/blob/v4.3.3.RELEASE/spring-web/src/main/java/org/springframework/web/filter/ForwardedHeaderFilter.java) 를 사용하면 됩니다.

Spring Boot 사용자는 `server.use-forward-headers` 프로퍼티를 애플리케이션에 설정하면됩니다. 자세한 내용은 [Spring Boot documentation](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-use-tomcat-behind-a-proxy-server) 을 확인하세요.