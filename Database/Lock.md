# Lock

면접에서 Lock에 대한 질문이 들어왔었다. 그런데 이 Lock을 전혀 대답하지 못했다. 트랜잭션이 많이 일어나는 애플리케이션에서는 이 Lock의 개념이 진짜 중요할 것 같은데 개념조차 몰랐고, 어떻게 쓰는지 어떤 목적으로 쓰는지 조차 몰랐다. 항상 질문이 `동시에 접근하면` ****이라는 전제가 깔리고 들어가는 질문이였는데, 이 개념을 캐치하지 못해서 대답하는 방법조차 모르는게 너무 치명적인 문제였다.

`동시에 접근하면` 이라는 키워드에서 `동시성`을 생각해냈어야 했고, 동시에 접근하여 처리되기 때문에 `일관성`을 생각해냈어야 했다. 좀 더 찾아보면 어땠을까 하는 아쉬움이 남는다.

그래서 늦었지만 이 `일관성`과 `동시성`을 보장하는 Lock에 대한 개념을 최대한 정리해보고자 한다.

또 물어보면 꼭 대답하자…ㅠ

Lock을 이해하기전에 전제조건을 깔아보자.

누군가 A라는 상품을 주문했는데 수량이 1개뿐이다. 근데 B라는 누군가가 동시에 상품을 주문했다.

그러면 어떻게 해야할까?

당연히 1개가 남았으니깐 둘중에 한명 누군가는 결제가 되었을 것이고, 또다른 누군가는 재고가 없어 주문이 불가하다고 메시지를 받을 것이다.

어떻게 가능한 것일까. 둘이 동시에 결제하기까지 완료해서 주문이 요청이되었는데, 누군 성공하고 누군 실패하고. 어떻게 의사결정한 것일까?

이 내용의 근간에는 `Lock` 이라는 개념이 존재한다. Lock은 트랜잭션 처리의 순서를 보장하기 위한 방법이다.  결국엔 둘이 아무리 동시에 눌렀다할지라도 먼저 수행되는 대사이 존재할 것이고, 그 대상이 처리 순서의 우위에 있으니깐 그 이후에 들어온 대상의 주문이 실패한 것이다.

그러면 이 `Lock`은 어떤 종류가 있는지 알아보자.

Lock의 종류로는 `Shared Lock`(공유 락)과 `Exclusive Lock`(베타 락)이 있다. 공유락은 Read Lock이라고도 부르고 베타락은 Write Lock 이라고도 부른다.

## Shared Lock

이 Read Lock이라고도 불리는 Shared Lock은 특정 Row를 읽을 때 사용되어지는 Lock이다. 그래서 Read Lock이라고 부른다. Shared Lock끼리는 동시에 접근이 가능하다. 여기서 `Shared Lock 끼리는` 이라는 부분에서 여러 락이 동시에 읽을 때는 이라고 유추해볼 수 있다. Shared Lock을 들고있는 SELECT 쿼리는 동일한 Row에 대해서 동시에 읽을 수 있다는 의미이다. 그러면 이 Shared Lock은 어떻게 쓰는 것일까?

InnoDB에서는 일반적인 SELECT 쿼리를 수행할 때, 대상 Row에 lock을 걸지 않는다. 만약 Shared Lock이 필요하다면, `{SELECT구문} **FOR UPDATE`** 를 작성하거나 `{SELECT구문} **LOCK IN SHARE MODE`**  를 작성하면 해당 SELECT가 되는 대상의 ROW에 SHARED LOCK이 걸리게 된다. 이렇게 되면, 위에서 언급한 바와 같이 또다른 트랜잭션이 row를 읽는 건 가능하지만 update는 불가능하다. 위 두 구문을 Locking read 라고 부른다.

### SELECT FOR UPDATE

데이터를 수정하기 위해 SELECT를 하는 중 이기 때문에 다른 트랜잭션이 ROW를 SELECT할 수 없도록 READ, WRITE락을 건다.

구문의 이름에서 유추할 수 있듯이 UPDATE를 하기 위해 SELECT를 하는 것이다. 즉, 앞서 FOR UPDATE를 통해 락을 건 트랜잭션은 이후 수정할 가능성이 있어 이 락을 걸었다고 보는 것이다.

때문에 누군가 대상 ROW를 SELECT할 때, 업데이트 될 수 있기 때문에, 락을 건 트랜잭션이 커밋될 때까지 기다렸다가 락이 풀리면 그다음 트랜잭션이 접근할 수 있다.

### LOCK IN SHARE MODE

SELECT 대상이 되는 ROW에 `WRITE LOCK`을 걸어 다른 트랜잭션에서 해당 ROW를 수정할 수 없게 한다.

FOR UPDATE와는 다르게 SELECT는 가능하다. 물론 트랜잭션이 LOCK을 걸고 있기 때문에 또 다른 트랜잭션에서 ROW를 수정하려면 이 LOCK이 거려있는 트랜잭션이 끝날때까지 기다려야 한다. 특정 트랜잭션이 LOCK IN SHARE MODE로 SHARED LOCK을 걸고있어도 다른 트랜잭션에서 LOCK IN SHARE MODE를 사용할 수 있다. 즉, 동시에 LOCK을 가지고 있는 상황이 가능하며, 이때 두 트랜잭션에서 레코드를 수정하려고하면 서로 락을 들고있기 때문에 데드락이 발생한다. 위에서 LOCK IN SHARE MODE는 SHARED LOCK을 들고 있는 경우 SELECT는 가능하지만 UPDATE는 불가능하다고 했다.

즉, LOCK IN SHARE MODE는 읽기만 수행하고 수정은 하지 않는다. 그리고 동시에 여러 트랜잭션에 READ LOCK을 획득할 수 있다. 또한, 해당 ROW를 수정하기 위해서는 LOCK을 걸고있는 트랜잭션이 끝나야 한다.


> 솔직히 절반정도 이해한 것 같다. s락과 x락이 존재하고, 여러 구문을 통해 s락과 x락을 획득하는 형태로 쓰여지는 것 같은데...
> 정리가 덜 된 것 같아 추가 조사가 필요할 것 같다...
> 이 Lock에 대한 부분은 제대로 다시한번 이해하고 예시를 만들어서 직접 경험한 뒤 마무리 지어야겠다.