# InnoDB Row-level Lock

면접에서 Lock에 대한 질문이 들어왔었다. 그런데 이 Lock을 전혀 대답하지 못했다. 트랜잭션이 많이 일어나는 애플리케이션에서는 이 Lock의 개념이 진짜 중요할 것 같은데 개념조차 몰랐고, 어떻게 쓰는지 어떤 목적으로 쓰는지 조차 몰랐다. 항상 질문이 `동시에 접근하면` 이라는 전제가 깔리고 들어가는 질문이였는데, 이 개념을 캐치하지 못해서 대답하는 방법조차 모르는게 너무 치명적인 문제였다.

`동시에 접근하면` 이라는 키워드에서 `동시성`을 생각해냈어야 했고, 동시에 접근하여 처리되기 때문에 `일관성`을 생각해냈어야 했다. 좀 더 찾아보면 어땠을까 하는 아쉬움이 남는다.

그래서 늦었지만 이 `일관성`과 `동시성`을 보장하는 Lock에 대한 개념을 최대한 정리해보고자 한다.

또 물어보면 꼭 대답하자…ㅠ

Lock을 이해하기전에 전제조건을 깔아보자.

누군가 A라는 상품을 주문했는데 수량이 1개뿐이다. 근데 B라는 누군가가 동시에 상품을 주문했다.

그러면 어떻게 해야할까?

당연히 1개가 남았으니깐 둘중에 한명 누군가는 결제가 되었을 것이고, 또다른 누군가는 재고가 없어 주문이 불가하다고 메시지를 받을 것이다.

어떻게 가능한 것일까. 둘이 동시에 결제하기까지 완료해서 주문이 요청이되었는데, 누군 성공하고 누군 실패하고. 어떻게 의사결정한 것일까?

이 내용의 근간에는 `Lock` 이라는 개념이 존재한다. Lock은 트랜잭션 처리의 순서를 보장하기 위한 방법이다.  결국엔 둘이 아무리 동시에 눌렀다할지라도 먼저 수행되는 대사이 존재할 것이고, 그 대상이 처리 순서의 우위에 있으니깐 그 이후에 들어온 대상의 주문이 실패한 것이다.

그러면 이 `Lock`은 어떤 종류가 있는지 알아보자.

Lock의 종류로는 `Shared Lock`(공유 락)과 `Exclusive Lock`(베타 락)이 있다. 공유락은 Read Lock이라고도 부르고 베타락은 Write Lock 이라고도 부른다.

## Shared Lock

이 Read Lock이라고도 불리는 Shared Lock은 특정 Row를 읽을 때 사용되어지는 Lock이다. 그래서 Read Lock이라고 부른다. shared lock을 획득한 상태로 select를 하게되면, 이 lock을 획득한 트랜잭션이 종료되기 전까지는 그 어떠한 트랜잭션도 lock이 걸린 row를 변경할 수 없게된다.

아래의 그림을 통해, shared lock을 사용한 트랜잭션과 이를 수정하려는 트랜잭션이 어떠한 상황이 발생되는지를 이해해보자.

![Untitled](InnoDB%20Row-level%20Lock/Untitled.png)

전제 조건)예시에서는 식별자 ID와 이름, 수량을 갖는 Products 테이블을 위 그림과 같이 만들어두었다.

상황) A유저는 고기만두 상품 페이지를 조회하였다. B유저는 고기만두를 실제 결제하였다.

물론, 상품페이지를 조회하는데 대상을 Lock을 걸지는 않을 것 같다. 하지만 Shared Lock을 설명하기 위해 이렇게 예시를 들었다고 생각하자.

1. 먼저 A유저가 상품페이지를 조회함과 동시에 B유저는 결제를 했다. 그래서 `순서1` 에서 트랜잭션이 동시에 시작되었다.
2. A유저가 고기만두를 조회하면서 Shared Lock을 획득하였다.
3. B유저는 고기만두를 결제하기 위해서(고기만두 수량을 업데이트하기 위해서) 고기만두를 조회하였다. 고기만두를 수정하기 위해 베타락(`여기서는 이해하지 못해도 됨`)을 획득하려고 하였으나, 이미 공유락이 해당 ROW에 존재하여 A유저 요청에 해당하는 트랜잭션1번이 끝날 때까지 대기하고 있는다.
4. 트랜잭션 1번이 commit되었고 A유저가 정상적으로 고기만두 상품페이지를 조회하였다.
5. 트랜잭션 2번이 배타락을 획득하였다, 그리고 고기만두의 수량을 감소시키기 위해 정상적으로 UPDATE 문을 수행하였다.
6. commit을 수행한 뒤 B유저의 결제가 정상적으로 완료되었다.

앞서 공유락에 대해 설명했던 것 처럼 대상 row에 대해 공유락을 가지고있던 트랜잭션 1로 인해 트랜잭션 2가 베타락을 획득할 수 없었다. 즉, 트랜잭션 1이 끝날때 까지 수정이 불가하였다.

즉 다시말하면, 공유락이 존재하는 row에 대해서는 배타락을 획득할 수 없다.

또한 공유락이 존재하는 row에는 추가적으로 공유락을 획득할 수 있다.

## Exclusive Lock

이 Write Lock이라고도 불리는 Exclusive Lock은 특정 Row를 쓸때 사용되어지는 Lock이다. 위의 공유락에서도 얼핏 언급되었지만, 이 베타락은 수정하기 위해(UPDATE 또는 DELETE) 획득하는 Lock이다.  배타락을 획득한 1번 트랜잭션이 있으면, 또다른 2번 트랜잭션이 배타락을 획득하기 위해서는 먼저 획득한 트랜잭션이 커밋되어야 다음 트랜잭션이 획득할 수 있다. 이번 내용을 준비하면서 사실 이부분이 가장 내가 잘 알지못했던 문제가 해결되는 부분이다. 동시에 1개밖에 안남은 고기만두를 살때, 누가 고기만두를 살 수 있는가… 결국엔 동시에 들어온 트랜잭션 중에 이 `배타락을 먼저 획득한 트랜잭션`에 해당하는 요청자가 고기만두를 살 수 있을 것이다. 자 그러면, 아래의 그림을 통해서, 좀더 확실하게 이해해보자.

![Untitled](InnoDB%20Row-level%20Lock/Untitled%201.png)

1. A유저가 김치만두를 결제함과 동시에 B유저도 김치만두를 결제를 했다. 그래서 `순서1` 에서 트랜잭션이 동시에 시작되었다.
2. A유저가 김치만두를 결제하기 위해 배타락을 획득하였다.
3. B유저 또한 고기만두를 결제하기 위해서 김치만두를 조회하였다. 하지만, 이미 A유저의 트랜잭션1이 김치만두 ROW에 대한 Lock을 보유하고 있어 트랜잭션 1번이 끝나기를 기다리고 있다.
4. A유저가 김치만두를 샀기때문에 수량이 한개가 줄어들었다. UPDATE문을 수행했다. (여전히 트랜잭션2는 트랜잭션1이 끝나기를 기다린다…)
5. 트랜잭션 1이 종료되었고 A유저는 김치만두 결제를 완료하였다.
6. 트랜잭션 2가 배타락을 획득하였고, 김치만두의 수량을 업데이트하기 위해 김치만두를 조회하였다. 어라? 아까 분명 결제하기 전에는 1개가 남았었는데, 그사이에 누군가 김치만두를 사갔다….
7. 결국 사지 못하고 커밋하여 종료…

이정도면 `Shared Lock`(`공유락`; `s락`)과 `Exclusive Lock`(`배타락`; `x락`)을 이해한 것 같다.

생각해보니 어려운 개념이 아니다. 그런데 왜이렇게 이해하는데까지 힘들었을까 싶다.. 이제는 누군가에게 s락과 x락에 대해서 예제를 들면서 보다 쉽게 설명해줄 수 있을 것 같다.

다음 내용에서는 row-level Lock말고도 다른 Lock도 좀 다뤄볼까한다.

![Untitled](InnoDB%20Row-level%20Lock/Untitled%202.png)

위의 내용을 이해했다면 공유락과 배타락에 대해 조사할때 일반적으로 볼 수 있는 이 표를 이해할 수 있을 것이다.