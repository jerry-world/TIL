# MySQL 락

MySQL에서는 테이블 데이터 동기화를 위한 테이블 락 외에도 메타데이터 락, 네임드 락 등 다양한 락을 제공한다.

락의 종류로는 

- 글로벌 락
- 테이블 락
- 네임드 락
- 메타데이터 락

으로 분류할 수 있다.

각각의 락 별로 어떠한 특징을 가지고 있는지 어떻게 동작하는지 예제와 함께 알아보자.

# 글로벌 락

글로벌 락은 MySQL에서 제공하는 락 중 범위가 가장 큰 락에 속한다. 이 글로벌 락은 `FLUSH TABLES WITH READ LOCK` 명령을 사용하여 락을 획득할 수 있다. 만약 특정 세션에서 이 글로벌 락을 획득하고 있다면, 다른 세션에서는 `SELECT`를 제외한 대부분의 DDL, DML 등을 수행할 경우 이 글로벌 락이 해제될 때까지 대기해야 한다. 글로벌 락의 영향을 받는 범위는 `MySQL 서버 전체`이다. 이 글로벌 락을 사용하는 경우는 DB 전체를 백업 뜨는 경우를 예로 들을 수 있다.

이 `FLUSH TABLES WITH READ LOCK` 으로 글로벌 락을 획득하는 방법은 명령을 수행함과 동시에 MySQL 서버에 존재하는 모든 테이블을 닫고 잠금을 걸게 된다. 이 명령이 수행하기 전에 테이블 또는 레코드에 쓰기 잠금이 걸려있는 경우에는 이 명령은 그 잠금을 획득하고있는 트랜잭션이 끝날때 까지 기다려야한다. 그 이유는 읽기 잠금을 걸기 전에 먼저 테이블을 `FLUSH` 해야하기 때문이다.

만약 쓰기잠금도 굉장히 오래걸렸고, 이 글로벌 락 작업도 굉장히 오래걸렸다면 실제 웹서비스에서 사용자는 그 시간만큼 굉장히 오래 기다려야 했을 것이다.

위 `FLUSH TABLES WITH READ LOCK` 명령은 사실 MySQL 8.0 버전에서 스토리지 엔진을 InnoDB로 채택하면서 부터는 잘 사용되어지지 않는다. 과거 MyISAM이나 MEMORY 스토리지 엔진에서 많이 사용하던 방식이다.

현재는 `Xtrabackup`이나 `Enterprise Backup`과 같은 백업 툴의 안정적인 실행을 위해 백업 락이 도입되었다.

```sql
mysql> LOCK INSTANCE FOR UPDATE;
--// 백업 실행
MYSQL> UNLOCK INSTANCE;
```

위처럼 특정 세션에서 백업 락을 획득하면 `테이블의 스키마`나 `사용자의 인증 관련 정보`를 변경할 수 없다.

- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE과 OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

# 테이블 락

테이블 락은 개별 테이블을 대상으로 설정되는 락이다. 특정 테이블에 대한 락을 획득할 수 있고, 명시적으로 명령어를 작성하여 테이블 락을 거는 방법도 있지만, 묵시적으로 특정 상황에 테이블 락이 걸리는 것도 있다.

테이블 락을 획득하려면 `LOCK TABLES table_name [READ | WRITE]` 명령을 수행하면되고, 테이블에 대한 읽기 또는 쓰기 락을 획득할 수 있다. 획득했던 락은 `UNLOCK TABLES` 명령으로 락을 반납한다.

```sql
mysql> LOCK TABLES user WRITE
mysql> update user set name = "이름 변경" where id="sypark";
mysql> UNLOCK TABLES
```

이또한 웹 애플리케이션과 같은 데에서는 잘 사용되어지지 않는 락이다.

묵시적 테이블 락은 MyISAM, MEMORY 스토리지 엔진에 해당하는 테이블에 데이터를 변경하면 자동으로 발생한다. 즉, 테이블 변경을 수행하는 쿼리를 시작하기전에 락을 획득하고 쿼리 수행후 자동으로 반납된다. 하지만 InnoDB 테이블의 경우에는 레코드 기반의 잠금을 제공하기 때문에, 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않는다. 따라서 DML 쿼리에는 이 테이블 락이 무시된다. 하지만, DDL과 같이 스키마를 변경하는 쿼리인 경우에는 테이블 락이 동작한다.

# 네임드 락(좀더 보충 필요)

네임드 락은 `GET_LOCK()` 함수를 사용하여 임의의 문자열에 대해 잠금을 설정하는 것이다.

쿼리에 임의의 문자열이 들어갔을 때 락을 거는 행위가 아니라, 그냥 락에 이름을 부여하는 것이다. 처음에는 임의의 문자열에 대한 락을 획득한다고 하길래, 쿼리에 특정 문자열이 작성된 것을 감지하고 이를 락하는 줄 알았다.

예를들어, 박선용 이라는 이름의 사용자가 user 테이블에 존재하는데 이 박선용 이라는 row를 수정할 때 박선용 락을 거는 그런 형태인 줄 알았다.

그게 아니라, 단순히 락에 이름을 부여하고 그 이름에 대한 락을 획득하는 것이다. 누군가 그 이름의 락이 존재하는지의 여부를 판단하고 이에 따라 트랜잭션을 수행하게 할지 기다릴지 그런 의사결정 정도를 행할 수 있다.

네임드 락은 분산락에 많이 사용된다고 한다. 분산락은 데이터베이스 등 공통된 저장소를 이용해서 자원이 사용중인지를 체크하는 목적으로 사용된다. Zookeeper 나 Redis 등에서 이 분산락을 보통 사용한다.

이 분산락은 데이터베이스 등 `공통된 저장소`를 이용하여 자원이 사용 중인지를 체크하며 `전체 서버에서 동기화된 처리`를 구현하는 것이 목적이다.

보통 선착순 이벤트나 한 유저라 여러번 클릭으로 동일한 상태를 유지할때 사용되어진다.

솔직히 말이 잘 이해가 되질 않는다. 공통된 저장소.. 전체 서버에서 동기화된 처리..

좀더 쉽게 말하면, 여러 서버로 구성된 환경에서 동일한 MySQL 데이터베이스를 바라보고 있고, 동일한 작업을 처리할 때 네임드 락을 사용해서 그 작업이 누군가 락을 획득하고있는지 없는지의 여부에 따라서 동시성 문제를 해결한다는 의미일까?

이부분은 좀더 찾아볼 필요가 있을 것 같다.. Redisson이나 Zookeeper를 생각하면, 프로듀싱 된 메시지를 컨슈밍하는 컨슈머가 누군가 소비를 했을 때, 해당 메시지에 대한 Lock을 들고있는 개념으로 말하는 것 같은데.. 뭔가 잘 이해가 가질 않는다..ㅎㅎ 다음에 더 찾아보자.

# 메타데이터 락

메타데이터 락은 테이블이나 뷰 등의 이름, 구조 등을 변경할 때 획득하는 락이다. 명시적으로 명령을 수행해서 락을 획득하는 것이 아니라, DDL 명령을 수행할 때 자동으로 획득하는 락이다.

과거 MySQL 5.5이전 버전에서는 DDL 작업시 트랜잭션을 고려하지 않는 문제가 있어 이를 해결하기 위해 메타데이터 락이라는 정책이 추가되었다.

![Untitled](MySQL%20락/Untitled.png)

![Untitled](MySQL%20락/Untitled%201.png)

위의 예제를 보자.

좌측 트랜잭션에서 select 쿼리로 products를 조회하였다.  우측 트랜잭션에서는 products 테이블을 product로 변경하는 DDL 명령을 수행하였다. 하지만 좌측 메타데이터 락에 의해, 우측 트랜잭션이 메타 데이터 락을 획득하기 위해 기다리고있다.