# SOLID

## SOLID 원칙

SOLID 설계원칙은 왜필요할까.

절차 지향 방식과 다르게 객체 간 연관성을 지니며 개발하는 OOP 방식에서 고려하여 작성하면 보다 객체 지향의 특징을 살릴 수 있는 부분들을 원칙화 한 것이다. 하여, SOLID 원칙에 따라 개발으 진행하면 이후 코드의 유지보수 성이나 재사용성 불필요한 중복성있는 코드들도 최소화할 수 있으며, 코드의 확장성에도 굉장히 유용하다.

결국 이 SOLID 원칙을 따라 개발하려는 개발자의 의도에는 코드를 복잡하지 않게, 이후 유지보수가 쉽고 확장성도 쉽게 하기 위한 마음가짐이 녹아있다고 생각한다.

이 SOLID 원칙은 2000년도에 로버트 마틴(Robert C. Martin)이라는 사람이 처음 소개하였다. 지금의 개발자들은 이 SOLID원칙을 객체 지향 프로그래밍을 하기위한 설계 원칙으로 당연하게 인지하고있다.

SOLID라는 이름은 각각의 원칙 앞글자를 따와 만들어진 고유 명사이다.

각 원칙들을 알아보자.

- 단일 책임 원칙(Single Responsibility Principle)


한 클래스는 하나의 책임만을 가져야한다. 쉽게말해서 하나의 클래스로 많은 일을 수행하지 말고, 한가지 일만 수행해야한다는 뜻이다. 

그러면 왜 한가지의 책임만 갖어야할까. 

하나의 책임이라는 것은 정답이 있는 것은 아니다. 매우 상대적인 개념이고, 어느 정도 수준으로 객체를 추상화 할지에 따라 이 책임의 기준도 달라지게 된다.  즉, 만들고자하는 클래스의 책임 기준은 연관관계에 존재하는 클래스 또는 클래스를 사용하는 대상(액터)에 따라 책임 기준이 달라질 수도 있다는 의미이다.

근데 이 액터가 여러개이고 액터가 그 클래스에게 요구하는 책임이 더 늘어나게 되면, 클래스에 다른 액터에게 의미가없는 역할들이 더 나열될 수 있다. 이럴땐 과감히 책임을 분리해야된다.


- 개방 폐쇄 원칙(Open Closed Principle)

여기서 말하는 개방과 폐쇄는 확장에는 열려있어야하고, 변경에는 닫혀있어야한다는 의미이다.  그러니깐, 기존 코드에 대한 변경없이 새로운 기능을 추가할 수 있어야한다는 의미라고 말할 수 있다.


- 리스코프 치환 원칙(Liskov Substitude Principle)

부모는 항상 자식으로 대체될 수 있어야한다는 뜻입니다. 예를들어 자동차가 있고 자동차를 구현한 k3 아반테 크루즈 가있다. 이러면 자동차가아닌 k3로 언제든 바뀔 수 있습니다.

- I는 Interface Segregation Principle로 인터페이스 분리 원칙입니다. 인터페이스는 가급적 작게만들어야하는데, 지켜지지 않으면 해당 인터페이스의 구현체가 불필요한 구현까지 해야하는 상황이 나올수도 있습니다.

- D는 Dependency Inversion Principle로 의존관계 역전 원칙입니다.
다형성과 연관성이 있으며, 구현클래스가아닌 추상클래스에 의존하라는 원칙입니다. 내용을 설명해보면 자동차와 타이어가 있을 떄, 윈터타이어를 끼고있었는데 날이따뜻해져서 일반타이어를 껴야되면 자동차가 구현클래스인 스노우타이어에 의존하고있을 때 자동차클래스에서 변경이 일어나야합니다. 이는 OCP를 위배함과 동시에 DIP를 위배하게되는데, 이때 일반타이어와 스노우타이어의 공통적인 성질을 갖는 추상클래스로 타이어를 의존하고있다면 추상클래스로써 이 DIP를 따르게 됩니다.