# 다형성

다형성(Polymorphism)은 `여러(Poly)의 모습(morph)`을 갖는 성질을 의미한다. 객체 지향 프로그래밍에서 바라보는 이 다형성은 한가지의 객체에 대해 여러가지의 모습을 갖는 것을 말한다. 이 여러가지 모습은 다시 말해, 여러개의 타입을 갖는다는 것이다. 즉, 다시 말하면 한 객체에 대해 다양한 타입을 갖는다고 말할 수 있다.

가령 승용차라는 객체가 있다면 기아의 K5, 현대의 소나타, 람보르기니의 아벤타도르 등 다양한 모습을 갖을 수 있게되는 것이다.

이 모든 모습들은 객체가 갖고있는 행위를 모두 수행할 수있다. 기본적으로 승용차가 할 수 있는 행위라면, 

- 스티어링 휠을 돌려 방향을 조향한다.
- 브레이크를 밟아 승용차를 멈춰 세운다.
- 엑셀레이터를 밟아 승용차를 전진 시킨다.

등 다양한 행위를 기본적으로 제공해야 한다.

K5라고해서 엑셀을 밟았을 때, 전진시키는(drive())를 제공하지 않는다면, 과연 이것을 차라고할 수 있겠는가?

이런 경우는 어떨까? K5는 전진시키는 기능에 해당하는 `drive()` 를 수행한다면, 최대 시속 180km까지밖에 달릴 수 없다고 가정해보자.

그런데 람보르기니 아벤타도르는  `drive()` 를 수행했을 때, 최대 350km까지 달릴 수 있다.

이처럼 다형성은 서로다른 타입(서로 다른 모습)의 공통적인 대상들이 존재할 때, 행위는 같지만 다른 방식으로 동작할 수 있다. 이를 우리는 `재정의(Override)` 를 통해 가능케 한다.

우리는 이러한 다형성을 객체지향 프로그래밍으로 표현하기 위해, 추상클래스, 인터페이스를 통해 이를 상속받거나 구현하여 처리할 수 있고, 오버로딩을 통해 표현할 수도 있다.(그렇다고 이 다형성이 추상클래스, 인터페이스, 오버라이딩, 오버로딩 이정도로 단정지어 표현할 수 있는 단어는 아니다..)

### 자 그러면 다형성이 없다면 이 객체 지향 프로그래밍은 어떻게 될까?

```java
public class Car{
	public String name;
	public int speed;
	
	public void speedUp(){
		if(name.equals("K5") && speed>180){
			System.out.println("K5의 최대 속력에 도달하였습니다.");
		}else if(name.equals("아벤타도르") && speed>350){
			System.out.println("아벤타도르의 최대 속력에 도달하였습니다.");
		}else{
			speed+=30;
		}
		System.out.println(name+"의 현재 주행 속도는 "+speed+"입니다.");
	}
	...
}
```

위의 drive 메서드를 보자. K5와 아벤타도르 주행될 때 각각의 분기에 따라 처리되도록 하였다. 뭐 아직까지는 문제가 없어보인다. 그런데 자동차 구매 붐이 일어나서, 엄청나게 많은 서로 각기다른 승용차 타입이 출시하게 되었다.

이런… 분기를 거침없이 늘려야겠다.

```java
public void drive(){
	if(name.equals("K5") && speed>180){
		System.out.println("K5의 최대 속력에 도달하였습니다.");
	}else if(name.equals("아벤타도르") && speed>350){
		System.out.println("아벤타도르의 최대 속력에 도달하였습니다.");
	}else if(이름 && 최고속도){
		S...
	}else if(이름 && 최고속도){
		S...
	}...
	System.out.println(name+"의 현재 주행 속도는 "+speed+"입니다.");
}
```

자동차 타입이 늘어나면 늘어날 수록 분기도 한없이 늘어나게 된다.

자, 그래 근성이 최고라고 더이상 출시되지않는다는 전제로 최대 500개까지 늘렸다고 해보자. 기업들이 미친듯이 달려든 이 승용차 시장. 그중 PSY(내 이름 이니셜…)사가 망해버렸다. 이 PSY 사는 A, B, C라는 이름으로 승용차를 출시하였다. 그런데 이미 망해버렸으니 더 이상 이세상에는 PSY 사의 자동차는 없다. 그러면 저 drive 메서드에서 각 분기를 일일이 찾아서 A, B, C를 또 지워줘야한다.

### 다형성을 적용하면?

이처럼 다형성을 위해 서로 각기 다른 특징을 가지고 있는 타입들의 공통적인 특징을 모아 추상화 해보자.!

```java
public class Car {
    public String name;
    public int speed = 0;

    public void speedUp(){
        this.speed+=30;
    }

    public void drive() {
        System.out.println(name + "의 현재 주행 속도는 " + speed + "입니다.");
    }
}
```

```java
public class K5 extends Car{
    public K5() {
        name = "k5";
    }

    @Override
    public void speedUp() {
        if(speed>180){
            System.out.println(name+"의 최대 속력에 도달하였습니다.");
        }else{
            speed+=30;
        }
        super.drive();
    }
}
```

```java
public class Aventador extends Car{
	public Aventador(){
		name = "Aventador";
	}

  @Override
  public void speedUp() {
      if(speed>350){
          System.out.println(name+"의 최대 속력에 도달하였습니다.");
      }else{
          speed+=50;
      }
      super.drive();
  }
	
	public void booster(){
		System.out.println("부스터를 사용하였습니다");
	}
}
```

자 이제 추상화된 Car 클래스를 상속받아 K5가 speedUp을 재정의(Override)하였다. K5는 위에서 언급한바와 같이 180km를 넘길 수 없다. 이처럼 승용차가 새 출시되면 이 추상화된 Car 클래스를 실체화하기만 하면된다.

마찬가지로 아벤타도르도 speedUp을 재정의하였다. 가속이 50씩 증가하는 아벤타도르는 350까지 속력을 낼 수 있도록 하였다. 아벤타도르만 갖는 기능인 부스터 기능도 추가할 수 있게되었다.

어쩌면 기존보다 코딩 양도 늘어났고, 구조가 복잡하게 느껴질 수도 있다. 하지만 양이 늘어난다면 이야기가 달라진다. 훨씬더 유지보수하기 쉬워졌고, 코드가 변경되더라도 각 차량에 대한 내용만 변경되기 때문에 각 객체에 대해서 단일 책임을 갖게 되었다. 또한, 공통된 기능은 추상화된 Car 클래스의 것을 그대로 쓰기때문에 코드의 재사용성도 올라갔다.

객체지향 프로그래밍이 갖는 장점은 구현에 대한 변경의 유연함이다. 이 유연함은 변경을 좀 더 편리하게, 피해주지 않으면서 할 수 있음을 포함한다. 캡슐화도 마찬가지로 다른 객체에 영향을 주지않으면서 유연하게 변경을 할 수 있도록 함에 있다. 

우리가 알고있던 다형성은 하나의 객체가 여러가지 타입을 갖는 것 정도 수준이였다면, 이번 글을 통해, 왜 여러가지 타입을 갖는지, 여러가지 타입을 갖으면 어떠한 이점이 있는지를 이해했으면 좋겠다.

> 💡 우리는 다형성을 흔히 다양한 형태를 갖는 것. Interface를 여러가지로 구현한 것. 추상클래스를 여러가지로 실체화한 것. 오버라이딩, 오버로딩 정도로만 생각한다. 다양한 형태에 대한 성질이니 틀린말은 아니다.
> 하지만 다형성은 “위의 내용으로 정의한다” 로 이해하지말고 다형성을 다양한 형태를 갖는것 그리고 왜 다형성을 고려해야하는지, 다형성을 고려하여 객체지향 프로그래밍을하면 어떤 이점이 있는지에 대한 초점을 두자는 것이다.

프로그래밍은 암기과목이 아니니말이다…

> 다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.
> 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다.
> 다시말해 인터페이스가 동일해야 한다는 것이다.
> [조영호 : 오브젝트]