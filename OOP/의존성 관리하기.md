# 의존성 관리하기

잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성된다.
이말인즉슨 한가지 일만 잘하는 작은 객체 여럿이 협력하여 잘 설계된 객체지향 애플리케이션을 만든다는 말과 같다.

그렇다고해서, 무조건 작게만든다고 능사는 아니다. 과도한 협력은 설계를 곤경에 빠뜨릴 수도 있기 때문이다.
과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다. 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 과감히 제거해야한다.

본 장에서는 의존성에 대해 이해하고, 의존성을 관리하는 방법을 살펴본다.

## 01.의존성 이해하기

### 변경과 의존성
두 객체가 협력하기 위해서는 의존성이 필요하다. 의존성은 실행시점과 구현시점에 서로 다른 의미를 가진다.

- 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

아래 코드를 살펴보자

```java
public class PeriodCondition implements DiscountCondition {
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

    public boolean isSatisfiedBy(Screening screening) {
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&
                startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
                endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```

실행 시점에 PeriodCondition의 인스턴스가 정상적으로 동작하기 위해서는 Screening 인스턴스가 존재해야한다.
만약 그렇지 않다면 예상대로 동작하지 못할 것이다.

이처럼 어떤 객체가 예정된 작업을 수행하기 위해서 다른 객체가 필요할 때, 이를 두 객체 사이에 의존성이 존재한다고 말한다.
의존성은 방향을 가지며 단방향이다. Screening이 변경될 때 PeriodCondition은 영향을 받지만, 그 반대는 성립하지 않는다.

이처럼 내용의 변경은 의존성에도 직접적인 영향을 미친다는 것을 알 수 있다. 위의 코드에서 보면 의존성이 Screening만 있는 것이 아니다.
DayOfWeek, LocalTime도 마찬가지이다. isSatisfiedBy의 시그니처 또한 변경되면 변경의 여파가 발생된다.

### 의존성 전이
의존성은 전이될 수 있다. 여기서 말하는 전이라는 것은, 위의 java 코드 예시에서, PeriodCondition이 Screening을 의존하고 있음으로써,
PeriodCondition이 간접적으로 Screening이 가지고 있는 의존성(Movie, LocalDateTime, Customer)들에도 간접적으로 의존한다는 의미이다.

즉, 한 대상과의 의존관계가 의존대상의 또다른 의존관계와 간접적으로 의존성을 띈다는 것을 말한다.

의존성은 직접 의존성과 간접 의존성으로 나눌 수 있다.
직접 의존성이란, 한 요소가 다른 요소에 직접 의존하는 경우를 가리킨다.
간접 의존성이란, 한 요소가 다른 요소에 의존함으로써 간접적으로 영향이 전파되는 것을 말한다.

이보다 더 중요한 사실은 개념적인 내용보다는 의존성을 띄고있으면 전이 성질에 의해 변경에 의해 영향을 받을 수 있다는 것이다.

### 런타임 의존성과 컴파일타임 의존성

먼저 런타임은 말 그대로 애플리케이션이 실행되는 시점을 의미하고, 컴파일타임은 작성된 코드를 컴파일하는 시점을 가르키지만 문맥에 따라서는 코드 그 자체를 가르키기도 한다.

실제 컴파일타임의 코드에서는 어떤 클래스의 인스턴스가 다양한 인스턴스를 갖기 위해서는 구체적인 클래스를 알아서는 안된다. 구체적인 클래스를 알게되면 새로운 대상을 추가하는데도 어렵고,
변경에도 자유롭지 못하다. 

실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다. 두 사이의 관계에서 여러 구체 클래스가 존재한다면, 구체적인 것에 해당하는 구체클래스 보다는 추상클래스를 통해, 구체적인 것을 알지 못하도록 해야한다.

### 컨텍스트 독립성
클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안된다. 구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.

클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다. 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 **컨텍스트 독립성** 이라고 한다.

설계가 유연해지기 위해서는 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야한다.

여기서 컨텍스트 독립적이라는 말은 각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다는 의미이다.

### 의존성 해결하기
의존성 해결이란, 컴파일 타임의 의존성을 런타임 시점에 구체적인 의존성을 띄는 것이다.

의존성을 해결하기 위해서는 일반적으로 다음과 같은 세가지 방법을 사용한다.
- 객체를 생성하는 시점에 생성자를 통해 의존성 해결
- 객체 생성 후 setter 메서드를 통해 의존성 해결
- 메서드 실행 시 인자를 이용해 의존성 해결

(Spring 의존성 주입...)




