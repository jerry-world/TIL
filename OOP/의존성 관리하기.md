# 의존성 관리하기

잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성된다.
이말인즉슨 한가지 일만 잘하는 작은 객체 여럿이 협력하여 잘 설계된 객체지향 애플리케이션을 만든다는 말과 같다.

그렇다고해서, 무조건 작게만든다고 능사는 아니다. 과도한 협력은 설계를 곤경에 빠뜨릴 수도 있기 때문이다.
과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다. 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 과감히 제거해야한다.

본 장에서는 의존성에 대해 이해하고, 의존성을 관리하는 방법을 살펴본다.

## 01.의존성 이해하기

두 객체가 협력하기 위해서는 의존성이 필요하다. 의존성은 실행시점과 구현시점에 서로 다른 의미를 가진다.

- 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

아래 코드를 살펴보자

```java
public class PeriodCondition implements DiscountCondition {
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

    public boolean isSatisfiedBy(Screening screening) {
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&
                startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
                endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```

실행 시점에 PeriodCondition의 인스턴스가 정상적으로 동작하기 위해서는 Screening 인스턴스가 존재해야한다.
만약 그렇지 않다면 예상대로 동작하지 못할 것이다.

이처럼 어떤 객체가 예정된 작업을 수행하기 위해서 다른 객체가 필요할 때, 이를 두 객체 사이에 의존성이 존재한다고 말한다.
의존성은 방향을 가지며 단방향이다. Screening이 변경될 때 PeriodCondition은 영향을 받지만, 그 반대는 성립하지 않는다.

이처럼 내용의 변경은 의존성에도 직접적인 영향을 미친다는 것을 알 수 있다. 위의 코드에서 보면 의존성이 Screening만 있는 것이 아니다.
DayOfWeek, LocalTime도 마찬가지이다. isSatisfiedBy의 시그니처또한 변경되면 변경의 여파가 발생된다.