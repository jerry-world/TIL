# 09. Server 시작하기

초기화 과정이 끝이낫다. 이제 본격적으로 Tomcat Server를 시작할 준비가 되었다.

앞서, Catalina의 load()를 통해, Engine, Connector, Service, Executor 등을 초기화하였다.

## Catalina.start()
```java
/**
     * Start a new server instance.
     */
    public void start() {

        if (getServer() == null) {
            load();
        }

        if (getServer() == null) {
            log.fatal(sm.getString("catalina.noServer"));
            return;
        }

        long t1 = System.nanoTime();

        // Start the new server
        try {
            getServer().start();
        } catch (LifecycleException e) {    
            log.fatal(sm.getString("catalina.serverStartFail"), e);
            try {
                getServer().destroy();
            } catch (LifecycleException e1) {
                log.debug(sm.getString("catalina.destroyFail"), e1);
            }
            return;
        }

        if (log.isInfoEnabled()) {
            log.info(sm.getString("catalina.startup",
                    Long.toString(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - t1))));
        }

        if (generateCode) {
            // Generate loader which will load all generated classes
            generateLoader();
        }

        // Register shutdown hook
        if (useShutdownHook) {
            if (shutdownHook == null) {
                shutdownHook = new CatalinaShutdownHook();
            }
            Runtime.getRuntime().addShutdownHook(shutdownHook);

            // If JULI is being used, disable JULI's shutdown hook since
            // shutdown hooks run in parallel and log messages may be lost
            // if JULI's hook completes before the CatalinaShutdownHook()
            LogManager logManager = LogManager.getLogManager();
            if (logManager instanceof ClassLoaderLogManager) {
                ((ClassLoaderLogManager) logManager).setUseShutdownHook(false);
            }
        }

        if (await) {
            await();
            stop();
        }
    }
```

getServer().start() 로 Server의 구체 구현체인 StandardServer에게 startInternal 수행을 요청한다.

사실은 LifecycleBase의 start()메서드로 시작하게 되는데, 현재의 인스턴스(StandardServer)가 시작가능한 상태인지에 대한 유효성을 검증 후, startInternal 을 호출하여,

구체 구현체인 StandardServer에 startInternal 메서드를 호출하여 작업을 위임하는 형태이다.

StandardServer에서의 startInternal 작업이 정상 종료되면, 부모 객체인 LifeCycleBase로 돌아와, 생명주기 상태 갱신을 끝낸다.

## StandardServer.startInternal()
StandardServer.startInternal() 를 살펴보자.

```java
@Override
    protected void startInternal() throws LifecycleException {

        fireLifecycleEvent(CONFIGURE_START_EVENT, null);
        setState(LifecycleState.STARTING);

        // Initialize utility executor
        synchronized (utilityExecutorLock) {
            reconfigureUtilityExecutor(getUtilityThreadsInternal(utilityThreads));
            register(utilityExecutor, "type=UtilityExecutor");
        }

        globalNamingResources.start();

        // Start our defined Services
        for (Service service : findServices()) {
            service.start();
        }

        if (periodicEventDelay > 0) {
            monitorFuture = getUtilityExecutor().scheduleWithFixedDelay(this::startPeriodicLifecycleEvent, 0, 60,
                    TimeUnit.SECONDS);
        }
    }
```

LifecycleBase 의 state 값을 STARTING으로 전환하고,

utility executor를 초기화한다. 여기서 utility executor는 톰캣 Server 레벨에서 공용적으로 사용하는 공용 스레드 풀이다.

JMX 관련 Background 나, 톰캣 내부적으로 동작하는 주기적인 작업 등이 해당 Executor에서 동작한다.

reconfigureUtilityExecutor를 통해, server.xml의 내용을 기반한 해당 Executor의 스레드를 할당하고,

UtilityExecutor 타입으로 해당 Executor를 JMX에 등록한다.

이후 globalNamingResources.start()를 통해, globalNamingResources의 상태또한 STARTING 상태로 전환한다.

이제부터 앞서 초기화 한 모든 서비드를 start한다.

StandardServer에 등록된 Service들을 순회하면서 각 서비스 인스턴스의 start 메서드(StandardServer.start())를 호출한다.

```java
// Start our defined Services
for (Service service : findServices()) {
    service.start();
}
```

## StandardService.startInternal()
드디어, Engine, Executor, Listener, Connector를 시작하는 구간이다. 상태를 STARTING으로 전환하고, engine, executor, mapperListener, connector 순으로 시작 메서드를 호출한다.
```java
@Override
    protected void startInternal() throws LifecycleException {

        if (log.isInfoEnabled()) {
            log.info(sm.getString("standardService.start.name", this.name));
        }
        setState(LifecycleState.STARTING);

        // Start our defined Container first
        if (engine != null) {
            engine.start();
        }

        for (Executor executor : findExecutors()) {
            executor.start();
        }

        mapperListener.start();

        // Start our defined Connectors second
        for (Connector connector : findConnectors()) {
            // If it has already failed, don't try and start it
            if (connector.getState() != LifecycleState.FAILED) {
                connector.start();
            }
        }
    }
```

## Engine.start()

