# 09-1-1. Host 시작하기
Engine이 자식 컨테이너에게 시작을 전이하면서, Engine의 자식 컨테이너인 Host의 시작하기로 넘어왔다.

Host 역시 ContainerBase를 상속하는 컨테이너이기 때문에,
자기 하위 컨테이너인 Context들에게도 동일하게 시작을 전이할 것이다.

먼저 Host의 구체 구현체인 StandardHost의 startInternal 메서드를 살펴보자.
```java
@Override
protected void startInternal() throws LifecycleException {

    // Set error report valve
    String errorValve = getErrorReportValveClass();
    if ((errorValve != null) && (!errorValve.isEmpty())) {
        try {
            boolean found = false;
            Valve[] valves = getPipeline().getValves();
            for (Valve valve : valves) {
                if (errorValve.equals(valve.getClass().getName())) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                Valve valve = ErrorReportValve.class.getName().equals(errorValve) ? new ErrorReportValve() :
                        (Valve) Class.forName(errorValve).getConstructor().newInstance();
                getPipeline().addValve(valve);
            }
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.error(sm.getString("standardHost.invalidErrorReportValveClass", errorValve), t);
        }
    }
    super.startInternal();
}
```


여기서는 크게 두 가지 일을 한다:

### ErrorReportValve 설정

getErrorReportValveClass()로 에러 리포트용 Valve 클래스 이름을 가져온다.

이미 파이프라인에 같은 클래스의 Valve가 있는지 확인하고,

없으면 ErrorReportValve(또는 설정된 커스텀 클래스)를 생성해서 pipeline에 추가한다.

즉, Host 레벨 파이프라인에 “에러 처리용 마지막 보루”를 꽂는 작업이다.

### 부모(ContainerBase)의 startInternal 호출

super.startInternal() 을 호출하면서, ContainerBase.startInternal()이 수행되며,

- Cluster 시작
- Realm 시작
- 자식 컨테이너(Context)들을 startStopExecutor로 시작
- Pipeline(Valves) 시작
- backgroundProcessor 스케줄링

같은 공통 로직이 그대로 한 번 더 적용된다.

여기서 ErrorReportValve의 역할은, 사용자의 요청을 정상적으로 처리하지 못했을 때 에러 페이지를 렌더링해주는 것이다.

서블릿/필터/Context에서 예외가 제대로 처리되지 않거나, 4xx/5xx 응답인데 바디가 비어 있는 상황에서

Host 파이프라인 마지막에 위치한 ErrorReportValve가 개입해서 브라우저에 보여줄 에러 페이지(기본 톰캣 에러 화면 또는 설정된 에러 페이지)를 생성한다.

이러한 Valve 모음들(pipeline 구조)은 나중에 한 번 따로 깊게 다뤄볼 만한 주제고, 지금은 “Host가 시작될 때, 에러 처리용 Valve를 보장하고 나서 ContainerBase 공통 로직(Cluster/Realm/자식 start 등)을 탄다” 정도로 이해하고 넘어가면 충분하다.

super.startInternal()이 호출된다는 것은,
앞에서 정리했던 ContainerBase.startInternal의 동작 원리가 Engine에 이어 Host에도 동일하게 적용된다는 것을 의미한다.

Engine에서는 자식이 Host였고,

Host에서는 자식이 Context이므로,

Host도 ContainerBase 로직을 통해 하위 컨테이너인 Context들을 재귀적으로 start 하게 된다.

[다음으로 (09-1-2. Context 시작하기(중요 포인트)) >](09-1-2.Context_시작하기(중요).md)