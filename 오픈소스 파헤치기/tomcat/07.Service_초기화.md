# 07. Service 초기화

Service는 하나의 Engine과 여러 Connector를 묶어 관리하는 단위로, 네트워크 계층(Coyote)과 애플리케이션 계층(Catalina) 간의 연결 관계를 조정한다.

아래의 내용은 StandardService의 초기화 메서드이다. 초기화 메서드에서는 engine과 executor, connector들을 초기화한다.

```java
@Override
protected void initInternal() throws LifecycleException {

super.initInternal();

if (engine != null) {
    engine.init();
}

// Initialize any Executors
for (Executor executor : findExecutors()) {
    if (executor instanceof JmxEnabled) {
        ((JmxEnabled) executor).setDomain(getDomain());
    }
    executor.init();
}

// Initialize mapper listener
mapperListener.init();

// Initialize our defined Connectors
for (Connector connector : findConnectors()) {
    connector.init();
}
}
```

```scss
"Service = Connector(s) + Engine"

     ┌───────────────────────────────┐
     │           Service             │
     │ ┌──────────────┐  ┌─────────┐ │
     │ │   Engine     │  │Connector│ │
     │ │ (Catalina)   │  │(Coyote) │ │
     │ └──────────────┘  └─────────┘ │
     └───────────────────────────────┘
                     │
     ┌───────────────────────────────┐
     │         StandardServer        │
     └───────────────────────────────┘

```

---

## Engine

Engine은 Catalina(서블릿 컨테이너) 계층의 루트 컨테이너이다.

Coyote로부터 전달받은 요청을 Host -> Context -> Wrapper로 라우팅하고 실행하는 주체이다.

아래는 Engine을 초기화하는 과정을 나열한다.

getRealm() 을 호출하여, Realm을 획득하거나 없을 경우 NullRealm을 생성 획득 한다.

부모의 initInternal() 을 호출하여 JMX 등록 및 라이프 사이클 초기화 작업을 수행한다.(Server 라이프사이클 초기화와 동일)

```java
@Override
protected void initInternal() throws LifecycleException {
    // Ensure that a Realm is present before any attempt is made to start
    // one. This will create the default NullRealm if necessary.
    getRealm();
    super.initInternal();
}
@Override
public Realm getRealm() {
    Realm configured = super.getRealm();
    // If no set realm has been called - default to NullRealm
    // This can be overridden at engine, context and host level
    if (configured == null) {
        configured = new NullRealm();
        this.setRealm(configured);
    }
    return configured;
}
```


---
## Connector
Connector는 server.xml에 정의된 Connector의 Port와 프로토콜에 따라 요청을 전달받고, 이를 전달하는 역할을 수행한다.
이렇게 네트워크 I/O 계층에 속하는 Connector는 성능, 보안, 프로토콜, 연결 관리에 관련된 다양한 속성들을 제공한다.
그 중 일부를 아래에 기술한다.

```
- port : 요청을 수신할 포트
- protocol : 사용할 프로토콜 핸들러 (HTTP/1.1 : org.apache.coyote.http11.Http11NioProtocol)
- address : 바인딩할 IP 주소
- connectionTimeout : 소켓 연결 후, 요청이 들어오지 않을 때 끊는 시간 (ms)
- redirectPort : SSL 필요 시 리다이렉트 할 포트 번호
- scheme : 요청의 스킴 지정(http / https)
- maxConnections : 도잇에 처리 간으한 최대 TCP 연결 수
- acceptCount : 대기열 길이 (트래픽이 몰릴 때, 큐에 대기 가능한 클라이언트 수)
- maxThreads : 요청을 처리할 워커 스레드 최대 수
- minSpareThreads : 최소 유지 스레드 수(Idle 포함)
```

싫제로 톰캣이 구동되면 Connector가 생성되는 큰 흐름은 아래와 같다.

Service의 초기화 과정에서는, 소속된 Connector들을 순회하며 각 Connector의 ProtocolHandler를 초기화하고,
그 내부 Endpoint가 실제 ServerSocketChannel을 열어 지정된 포트를 Listen할 준비를 수행한다.

```scss
Catalina.load()
   ↓
Digester로 server.xml 파싱
   ↓
<Server> → StandardServer 객체 생성
<Service> → StandardService 객체 생성
<Connector> → Connector 객체 생성
   ↓
Catalina.start()
   ↓
StandardServer.init()
   ↓
StandardService.init()
   ↓
Connector.init()
   ↓
ProtocolHandler.init() (Http11NioProtocol 등)
   ↓
ServerSocketChannel open()
```

### Connector 초기화
Conenctor 초기화 과정은 ProtocolHandler를 초기화하고 Adapter를 연결하는 과정이다. 이때 `Coyote`가 처음으로 등장한다.

```java
    @Override
protected void initInternal() throws LifecycleException {

    super.initInternal();

    if (protocolHandler == null) {
        throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerInstantiationFailed"));
    }

    // Initialize adapter
    adapter = new CoyoteAdapter(this);
    protocolHandler.setAdapter(adapter);

    // Make sure parseBodyMethodsSet has a default
    if (null == parseBodyMethodsSet) {
        setParseBodyMethods(getParseBodyMethods());
    }

    if (JreCompat.isJre22Available() && OpenSSLStatus.getUseOpenSSL() && OpenSSLStatus.isAvailable() &&
            protocolHandler instanceof AbstractHttp11Protocol<?> jsseProtocolHandler) {
        // Use FFM and OpenSSL if available
        if (jsseProtocolHandler.isSSLEnabled() && jsseProtocolHandler.getSslImplementationName() == null) {
            // OpenSSL is compatible with the JSSE configuration, so use it if it is available
            jsseProtocolHandler
                    .setSslImplementationName("org.apache.tomcat.util.net.openssl.panama.OpenSSLImplementation");
        }
    } else if (AprStatus.isAprAvailable() && AprStatus.getUseOpenSSL() &&
            protocolHandler instanceof AbstractHttp11Protocol<?> jsseProtocolHandler) {
        // Use tomcat-native and OpenSSL otherwise, if available
        if (jsseProtocolHandler.isSSLEnabled() && jsseProtocolHandler.getSslImplementationName() == null) {
            // OpenSSL is compatible with the JSSE configuration, so use it if APR is available
            jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation.class.getName());
        }
    }
    // Otherwise the default JSSE will be used

    try {
        protocolHandler.init();
    } catch (Exception e) {
        throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerInitializationFailed"), e);
    }
}
```

`Coyote`는 통신 계층(HTTP 프로토콜 스택)을담당하는 엔진이다. 서블릿 컨테이너(Catalina)와 네트워크 계층 사이의 브릿지 역할을 수행하는 프로토콜 처리기이다.

Connector가 생성되는 시점에 Connector의 protocol 속성에 따라 작성된 프로토콜을 기반으로 Coyote의 ProtocolHandler는 실제 프로토콜 객체를 만든다.
```java
    static ProtocolHandler create(String protocol)
            throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException,
            InvocationTargetException, NoSuchMethodException, SecurityException {
        if (protocol == null || "HTTP/1.1".equals(protocol) ||
                org.apache.coyote.http11.Http11NioProtocol.class.getName().equals(protocol)) {
            return new org.apache.coyote.http11.Http11NioProtocol();
        } else if ("AJP/1.3".equals(protocol) ||
                org.apache.coyote.ajp.AjpNioProtocol.class.getName().equals(protocol)) {
            return new org.apache.coyote.ajp.AjpNioProtocol();
        } else {
            // Instantiate protocol handler
            Class<?> clazz = Class.forName(protocol);
            return (ProtocolHandler) clazz.getConstructor().newInstance();
        }
    }
```
이 생성된 프로토콜 객체를 CoyoteAdapter를 이용하여, Catalina와 Coyote를 연결해준다.

이로써, 소켓 I/O 담당을 수행하는 Connector가 실제 Port를 bind 하고(수신 대기), accept할 수 있는 상태가 된 것이다.

[다음으로 (08.Executor 초기화)](08.Executor_초기화.md)