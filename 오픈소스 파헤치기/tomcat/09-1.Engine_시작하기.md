# 09-01. Engine 시작하기

여기서 말하는 Engine은 앞서 초기화된, 서블릿 컨테이너의 루트 컨테이너에 해당하는 Catalina를 의미한다.

ContainerBase의 구체구현체 StandardEngine에서는 start 시, ContainerBase에게 작업을 위임한다.(물론, Lifecycle 상태도 전환한다.)

```scss
LifecycleBase
 ㄴ ContainerBase
    ㄴ StandardEngine
```

ContainerBase를 상속받는 주요 컨테이너 주체에는 Engine, Host, Context, Wrapper가 있는데 이 ContainerBase의 startInternal 메서드를 잘 파악하면,
나머지는 이 start 구조와 대동소이하다.

Engine, Host, Context, Wrapper라는 단어를 여기서 처음 다루게 되었는데, 이 각 항목들은 톰캣 컨테이너에 해당한다. 때문에 ContainerBase를 상속받게 되는 것이다.

```java
@Override
protected void startInternal() throws LifecycleException {

    reconfigureStartStopExecutor(getStartStopThreads());

    // Start our subordinate components, if any
    logger = null;
    getLogger();
    Cluster cluster = getClusterInternal();
    if (cluster instanceof Lifecycle) {
        ((Lifecycle) cluster).start();
    }
    Realm realm = getRealmInternal();
    if (realm instanceof Lifecycle) {
        ((Lifecycle) realm).start();
    }

    // Start our child containers, if any
    Container[] children = findChildren();
    List<Future<Void>> results = new ArrayList<>(children.length);
    for (Container child : children) {
        results.add(startStopExecutor.submit(new StartChild(child)));
    }

    MultiThrowable multiThrowable = null;

    for (Future<Void> result : results) {
        try {
            result.get();
        } catch (Throwable t) {
            log.error(sm.getString("containerBase.threadedStartFailed"), t);
            if (multiThrowable == null) {
                multiThrowable = new MultiThrowable();
            }
            multiThrowable.add(t);
        }

    }
    if (multiThrowable != null) {
        throw new LifecycleException(sm.getString("containerBase.threadedStartFailed"),
                multiThrowable.getThrowable());
    }

    // Start the Valves in our pipeline (including the basic), if any
    if (pipeline instanceof Lifecycle) {
        ((Lifecycle) pipeline).start();
    }

    setState(LifecycleState.STARTING);

    // Start our thread
    if (backgroundProcessorDelay > 0) {
        monitorFuture = Container.getService(ContainerBase.this).getServer().getUtilityExecutor()
                .scheduleWithFixedDelay(new ContainerBackgroundProcessorMonitor(), 0, 60, TimeUnit.SECONDS);
    }
}
```

## 1. Start Stop Executor 설정

가장 먼저 `reconfigureStartStopExecutor(getStartStoupThreads())` 부분은, 컨테이너의 start/stop 작업용 스레드풀을 구성하는 메서드이다.

기본값 1로 단일 스레드로 동작하는 Executor를 획득한다(스레드풀 흉내내만 내는..). 기본값이 아닌 더큰 수로 할당하면 여러 스레드된 스레드 풀을 구성할 수 있다.

이때, 앞서 서버 초기화과정에서 주입한 UtilityExecutor를 활용한다. UtilityExecutor가 이미 구성되어있다면, 스레드풀을 재 구성하여 할당한다.

## 2. 클러스터 시작하기

```java
Cluster cluster = getClusterInternal();
if (cluster instanceof Lifecycle) {
    ((Lifecycle) cluster).start();
}
```

여기서 클러스터링을 깊게 다루지는 않겠지만, 간단하게 설명하면 이 클러스터는 서로다른 JVM에 띄워진 톰캣의 세션을 복제하는 클러스터링이라고 볼 수 있다.

톰캣 입장에서 세션 복제라 함은 `HttpSession` 객체 자체를 네트워킹을 통해 다른 노드로 동기화하는 것을 의미한다. In-memory(톰캣 메모리) 수준의 세션 인증 방식을 사용하는 애플리케이션에서는 해당 클러스터링 기능을 사용하면,

서로 HA 구성된 다른 톰캣 위의 애플리케이션 간의 세션을 동일하게 유지할 수 있다. 

```scss
[ Tomcat1:8080 ] <-> [ Tomcat2:8080 ]
         ↑                  ↑
         └── 클러스터로 묶여 있음( 서로 HttpSession을 동기화함)
```

Cluster가 구성되어 있다면, Cluster 내부 컴포넌트를 모두 start 한다. 여기서 내부 컴포넌트 들은 Channel, Receiver, Sender 등이 존재한다.(SimpleTcpCluster.class 참고)

## 3. Realm 시작하기
```java
Realm realm = getRealmInternal();
if (realm instanceof Lifecycle) {
    ((Lifecycle) realm).start();
}
```
Realm은 톰캣 내에서 사용자 인증과 권한 부여를 처리하는 주요 보안 컴포넌트이다. Tomcat 서블릿 수준에서 인증/인가를 직접적으로 다룰 수 있는 주요 컴포넌트인데,

보통 Spring 생태계에서는 Spring Security를 지배적으로 많이 사용하기 때문에, Realm 활용도가 낮은 편이다.

이 RealM에 대해 간단하게만 다뤄본다면, 톰캣 컨테이너 계증에서 web.xml에 작성된 security-constraint 가 트리거가 되어 동작하는 인증/인가 매커니즘의 주체라할 수 있다.

Realm이 사용자 정보는 DB/LDAP 등을 직접 조회하여 톰캣 내부 구현체인 Principal로 인증 주체를 획득하고 인증/인가 처리를 수행한다.(인증방식으로는 BASIC, FORM ,DIGEST, CLIENT-CERT 등이 있음.)

톰캣 인증 방식 절차

```scss
브라우저 → 톰캣 Connector
         → Engine/Host/Context Pipeline
             → AuthenticatorValve
                 → Realm.authenticate(username, password)
                     → Principal 생성
                     → HttpServletRequest.getUserPrincipal() 채움
         → 서블릿 실행
```

(아마도 BASIC/FORM 등 표준 서블릿 스펙 기반의 인증 방식만을 제공해서, 더더욱이 사용되지 않을 것 같다. JWT, OAuth2, SAML 등.. 지원이 안되니)

아무튼, 이 Realm 이 구성되어있으면 시작한다. 클러스터 시작과 동일한 방식이다. 현재 컨테이너에 Realmn이 설정되어있는지를 확인하고, Lifecycle을 시작상태로 전환한다.

(구체적으로는 MemoryRealm, JDBCRealm, DataSourceRealm, JNDIRealm 등의 구현체가 start된다.) 이과정에서 DB와 연결하거나, tomcat-users.xml 을 파싱하는 등

각 구현체에서의 `시작하기` 동작이 마무리된다. (톰캣이 인증 요청을 처리할 준비가 완료됨. 물론 Realm을 쓴다면)

## 4. 자식 컨테이너 시작하기(재귀적으로다가)
```java
// Start our child containers, if any
Container[] children = findChildren();
List<Future<Void>> results = new ArrayList<>(children.length);
for (Container child : children) {
    results.add(startStopExecutor.submit(new StartChild(child)));
}

MultiThrowable multiThrowable = null;

for (Future<Void> result : results) {
    try {
        result.get();
    } catch (Throwable t) {
        log.error(sm.getString("containerBase.threadedStartFailed"), t);
        if (multiThrowable == null) {
            multiThrowable = new MultiThrowable();
        }
        multiThrowable.add(t);
    }

}
if (multiThrowable != null) {
    throw new LifecycleException(sm.getString("containerBase.threadedStartFailed"),
            multiThrowable.getThrowable());
}
```
Engine 입장에서의 자식컨테이너(Host)들을 모두 획득(ContainerBase에서 동작)하여, startStopExecutor에게 작업을 위임한다.

여기서 Future 인터페이스를 활용하여, 비동기 - 병렬 처리하게 되는데, 

startStopExecutor.submit(new StartChild(child)) 호출 시점에 각 자식 컨테이너의 start 작업이 실행자로 스케줄링된다.

이후 result.get() 호출 시점에 해당 작업이 완료될 때까지 블로킹하며, 모든 자식 컨테이너의 start가 끝났는지를 확인한다.

하지만 앞서 선언한 startStopExecutor를 활용하는 것이기 때문에, 스레드 수를 1로 고정해서 사용한다면, 사실 직렬인 셈이다.



```java
private record StartChild(Container child) implements Callable<Void> {

    @Override
    public Void call() throws LifecycleException {
        child.start();
        return null;
    }
}
```

이후, `result.get()`을 호출하여, 자식컨테이너가 시작될때까지 블로킹한 뒤, 순차적으로 완료됨을 확인한다.(호스트 시작 중 하나라도 실패하면 예외)

이 지점이 굉장히 중요한 지점인게, 재귀적으로 자식 컨테이너를 타고 내려가면서 모두 start하는 지점이다.

Container는 부모 자식관계를 맺고있는데, 일반적인 Tomcat 구조 그림 레퍼런스를 살펴보면,

Server > Service > Engine > Host > Context 구조로 되어있다. 이말인 즉슨, 앞서 findChildren을 수행 했을 때, 
- Engine에서는 Host를
- Host에서는 Context를

자식으로 갖기 때문에, 이 자식들을 재귀적으로 호출하면서 start 작업을 수행하는 것이다.

Host를 그리고 Context를 더 깊히 살펴볼 필요는 있지만, 이 문서에서는 아.. 재귀적으로 자식 컨테이너들을 타고가면서 시작작업을 수행하는구나 정도로 이해하자.

## 5. Pipeline 과 Valve 시작하기
```java
// Start the Valves in our pipeline (including the basic), if any
if (pipeline instanceof Lifecycle) {
    ((Lifecycle) pipeline).start();
}
```
여기서 Pipeline은 ContainerBase에 붙어있는 Valve 체인을 의미한다. 마치 Filter 체인이 서블릿 안쪽의 필터링이라면, Valve 체인은 톰캣 컨테이너 레벨의 필터링이라고 볼 수 있다.

각 컨테이너 유형마다 자기만의 pipeline을 가지고 있고, 그안에서 여러 Valve와 연결된다.

Engine은 ErrorReportValve와 같은 전역 처리를 수행한다.

아무튼, 이 시점에 톰캣 내부 필터 체인들이 활성화 된다 정도로 이해하고 넘어가자.

## 6. STARTING으로 상태 전이

Engine의 시작 작업이 거의 마무리가 되었다, STARTING으로 상태를 전이한다. 아직은 STARTED가 아님..

## 7. backgroundProcessor 스레드 등록
```java
// Start our thread
if (backgroundProcessorDelay > 0) {
    monitorFuture = Container.getService(ContainerBase.this).getServer().getUtilityExecutor()
            .scheduleWithFixedDelay(new ContainerBackgroundProcessorMonitor(), 0, 60, TimeUnit.SECONDS);
}
```
각 컨테이너는 `backgroupdProcessorDelay` 라는 멤버 필드를 가지고 있다.
- 0 이하 -> background 작업 안함
- 양수 N -> 대략 N초 간격으로 backgroundProcess()를 돌림 

여기서는 60초마다 한번씩 ContainerBackgroundProcessorMonitor를 돌리도록 되어있다.

이 ContainerBackgroundProcessorMonitor의 역할은 하위 컨테이너들을 재귀적으로 호출하면서, 정상적으로 엔진이 동작하고 있는지를 탐지하는 역할을 담당한다.

---

이 지점까지 오면 Engine(Catalina)이 어떻게 시작하는지 대략적으로 이해한 것이다.

Engine의 자식 컨테이너인 Host, Context를 순차적으로 살펴보면, Engine의 시작 구조를 보다 심층적으로 확인해보자.

[다음으로 (09-1-1.Host 시작하기)](09-01-1.Host_시작하기.md)